{
    "0": {
        "level 1": [
            [
                "def kappa_weighted(testData, k, w):\n    data = np.array(testData)\n    weights = np.array(w)\n    \n    N = len(data)\n    n = np.sum(data, axis=0)\n    \n    p0 = KappaCalculator.kappa(testData, k)\n    pe = KappaCalculator.fleiss_kappa(testData, N, k, n)\n    \n    num = np.sum(np.sum(weights * data, axis=0) ** 2) - N * np.sum(np.sum(weights * data, axis=0) ** 2)\n    den = N * N * (np.sum(weights * n) ** 2) - N * np.sum(np.sum(weights * n ** 2, axis=0))\n    \n    return (p0 - pe) / (1 - pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    total_subjects = np.sum(testData)\n    observed_agreement = KappaCalculator.kappa(testData, k)\n    expected_agreement = KappaCalculator.fleiss_kappa(testData, total_subjects, k, k)\n    kappa = (observed_agreement - expected_agreement) / (1 - expected_agreement)\n    weighted_kappa = kappa / (1 - expected_agreement)\n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    n = np.sum(testData)\n    N = len(testData)\n    p_e = KappaCalculator.fleiss_kappa(testData, N, k, n)\n    p_o = KappaCalculator.kappa(testData, k)\n    return (p_o - p_e) / (1 - p_e)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        observed_agreement = self.fleiss_kappa(testData, N, k, n)\n        possible_agreement = self.kappa(testData, k)\n        \n        total_items = np.sum(testData)\n        weights_agreement = np.sum(np.multiply(testData, w))\n        \n        p0 = observed_agreement / total_items\n        pe = weights_agreement / np.square(total_items)\n        \n        return (p0 - pe) / (1 - pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        n = len(testData)\n        N = sum(sum(row) for row in testData)\n        P = self.kappa(testData, k)\n        PE = self.fleiss_kappa(testData, N, k, n)\n        if PE == 1.0:\n            return 1.0\n        else:\n            return (P - PE) / (1.0 - PE)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    n = np.sum(testData)\n    p0 = KappaCalculator.kappa(testData, k)\n    pe = KappaCalculator.fleiss_kappa(testData, n, k, n)    \n    return (p0 - pe) / (1 - pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    total = np.sum(testData)\n    observed_agreement = np.trace(testData) / total\n    expected_agreement = np.sum(np.sum(testData, axis=0) * np.sum(testData, axis=1)) / (total ** 2)\n    weights = np.outer(np.sum(testData, axis=0), np.sum(testData, axis=1)) / total\n\n    weighted_observed_agreement = np.sum(np.multiply(testData, w)) / total\n    weighted_expected_agreement = np.sum(np.multiply(weights, w)) / total\n\n    return (weighted_observed_agreement - weighted_expected_agreement) / (1 - weighted_expected_agreement)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    weighted_sum = 0\n    for i in range(k):\n        for j in range(k):\n            weighted_sum += w[i][j] * testData[i][j]\n    \n    total_sum = np.sum(testData)\n    expected_agreement = 0\n    for i in range(k):\n        expected_agreement += np.sum(testData[i]) * np.sum(testData[:, i])\n    \n    expected_agreement /= (total_sum * total_sum)\n    observed_agreement = np.trace(testData) / total_sum\n    \n    return (observed_agreement - expected_agreement) / (1 - expected_agreement)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    observed_agreement = np.trace(testData) / np.sum(testData)\n    expected_agreement = np.sum(np.sum(testData, axis=1) * np.sum(testData, axis=0)) / np.sum(testData) ** 2\n    weights_matrix = np.outer(np.sum(testData, axis=1), np.sum(testData, axis=0))\n    weights_sum = np.sum(np.multiply(weights_matrix, w))\n    \n    return (observed_agreement - expected_agreement) / (1 - expected_agreement)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        # Calculate observed agreement\n        r = np.sum(np.sum(testData**2 - testData, axis=1) / (np.sum(testData) - 1))\n        # Calculate expected agreement\n        p = np.sum(np.sum(w * np.sum(testData, axis=0)**2) / (np.sum(testData)**2))\n        return (r - p) / (1 - p)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        total = np.sum(testData)\n        prob = 0\n        for i in range(k):\n            prob += (np.sum(np.multiply(testData[i], w[i])) / total) ** 2\n        prob_expected = 0\n        for i in range(k):\n            prob_expected += (np.sum(np.sum(testData, axis=0) * np.sum(testData, axis=1) * w[i]) / total ** 2)\n        kappa = (prob - prob_expected) / (1 - prob_expected)\n        return kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    p0 = KappaCalculator.kappa(testData, k)\n    pe = np.sum(np.sum(w, axis=0) ** 2) / ((np.sum(w) ** 2) * k)\n    return (p0 - pe) / (1 - pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    N = len(testData)\n    n = len(testData[0])\n    p_e = 0.0\n    for i in range(n):\n        for j in range(n):\n            p_e += w[i][j] ** 2\n    \n    p_o = kappa(testData, k)\n    return (p_o - p_e) / (1 - p_e)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    sum_o = 0\n    sum_e = 0\n    N = len(testData)\n    n = len(testData[0])\n    \n    for i in range(N):\n        sum_o += np.sum(np.multiply(w, testData[i]))\n        sum_e += np.sum(np.multiply(w, np.sum(testData, axis=0))) / n\n    \n    P_o = sum_o / (N * n)\n    P_e = sum_e / (N * n)\n    \n    return (P_o - P_e) / (1 - P_e)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        total = len(testData)\n        p0 = KappaCalculator.kappa(testData, k)\n        pe = sum([sum(w[i]) ** 2 for i in range(k)]) / (total - 1)\n        kappa = (p0 - pe) / (1 - pe)\n        return kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        pass",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    observed_agreement = kappa(testData, k)\n    expected_agreement = fleiss_kappa(testData, np.sum(testData), k, np.sum(w))\n    return 1 - (1 - observed_agreement) / (1 - expected_agreement)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    N = len(testData)\n    n = sum([sum(row) for row in w])\n    p_e = sum([sum([w[i][j] * sum(testData[i]) * sum(testData[j]) for j in range(k)]) for i in range(k)]) / (N * N)\n    p_o = sum([sum([w[i][j] * sum([testData[i][a] * testData[j][a] for a in range(N)]) for j in range(k)]) for i in range(k)]) / (N * N)\n    return (p_o - p_e) / (1 - p_e)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    sum_o = sum_e = 0\n    N = sum([sum(row) for row in testData])\n    n = len(testData)\n    \n    for i in range(n):\n        sum_o += sum([w[j][l] * testData[i][j] * testData[i][l] for j in range(k) for l in range(k)])\n        sum_e += sum([w[j][l] * sum([testData[i][j] * testData[i][l] for i in range(n)]) for j in range(k) for l in range(k)])\n        \n    po = sum_o / N\n    pe = sum_e / (N * N)\n    \n    kappa = (po - pe) / (1 - pe)\n    \n    return kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    total = np.sum(testData)\n    observed_agreement = np.trace(testData) / total\n\n    expected_agreement = 0\n    for i in range(k):\n        row_total = np.sum(testData[i, :])\n        col_total = np.sum(testData[:, i])\n        expected_agreement += (row_total * col_total) / total\n\n    kappa = (observed_agreement - expected_agreement) / (1 - expected_agreement)\n    weighted_kappa = 1 - ((1 - kappa) / (1 + np.trace(w)))\n\n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        total = np.sum(testData)\n        prob = 0\n        for i in range(k):\n            prob += (np.sum(np.multiply(testData[i], w[i])) / total) ** 2\n        prob_expected = 0\n        for i in range(k):\n            prob_expected += (np.sum(np.sum(testData, axis=0) * np.sum(testData, axis=1)) / (total ** 2)) ** 2\n        kappa = (prob - prob_expected) / (1 - prob_expected)\n        return kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    observed_agreement = kappa(testData, k)\n    expected_agreement = fleiss_kappa(testData, np.sum(testData), k, np.sum(w))\n    return 1 - (1 - observed_agreement) / (1 - expected_agreement)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    N = len(testData)\n    n = sum([len(testData[i]) for i in range(N)])\n    p = KappaCalculator.fleiss_kappa(testData, N, k, n)\n    P = KappaCalculator.kappa(testData, k)\n    w_total = np.sum(w)\n    W = (1 / (n * (n - 1))) * np.sum(w * np.sum(p, axis=1) ** 2)\n    E = np.sum(p ** 2, axis=0)\n    kappa_weighted = (P - E) / (1 - E)\n    return kappa_weighted",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    sum_o = sum_e = 0\n    n = sum(map(sum, testData))\n    N = len(testData)\n\n    for j in range(k):\n        sum_o += sum(testData[j][j] * w[j][j])\n        sum_e += sum(testData[j]) * sum([w[j][l] for l in range(k)])\n\n    P_e = sum([sum(testData[l]) * sum([w[l][j] for l in range(k)]) for j in range(k)]) / (n * n)\n    P_o = sum_o / n\n    kappa = (P_o - P_e) / (1 - P_e)\n    return kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        total = len(testData)\n        p = np.sum(np.sum(w * testData, axis=1) / total, axis=0) / k\n        P_e = np.sum(np.sum(w**2, axis=1), axis=0) / (k * k)\n        kappa = (p - P_e) / (1 - P_e)\n        return kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        sum_o = 0\n        sum_e = 0\n        N = len(testData)\n        \n        for i in range(k):\n            sum_o += w[i][i] * testData[i][i]\n            sum_e += np.sum(w[i]) * np.sum(testData[i]) / N\n        \n        return (sum_o - sum_e) / (N - sum_e)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        total_agreements = np.trace(testData)\n        total_items = np.sum(testData)\n        \n        po = total_agreements / total_items\n        \n        pe = 0\n        for i in range(k):\n            pe += np.sum(testData[i]) * np.sum(w[i]) / total_items ** 2\n        \n        return (po - pe) / (1 - pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    total = np.sum(testData)\n    p0 = KappaCalculator.kappa(testData, k)\n    pe = np.sum(np.sum(np.power(testData, 2), axis=1) / total ** 2)\n    return (p0 - pe) / (1 - pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        pass",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        total_items = np.sum(testData)\n        p_o = 0\n        p_e = 0\n        for i in range(k):\n            for j in range(k):\n                p_o += w[i][j] * testData[i][j]\n                p_e += np.sum(testData[i, :]) * np.sum(w[i, :]) * np.sum(testData[j, :]) * np.sum(w[j, :])\n        p_o /= total_items\n        p_e /= (total_items ** 2)\n        return (p_o - p_e) / (1 - p_e)",
                false
            ]
        ],
        "level 2": [
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    total_sum = np.sum(testData)\n    P0 = np.sum(w * testData)\n    Pe = np.sum(col_sums) * np.sum(row_sums) / total_sum\n    Pe = np.sum(Pe * w)\n    weighted_kappa = 1 - P0 / Pe\n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    data = np.array(testData, dtype=int)\n    weight = np.array(w, dtype=int)\n    \n    row_sums = np.sum(data, axis=1)\n    column_sums = np.sum(data, axis=0)\n    total_sum = np.sum(data)\n    \n    P0 = np.sum(weight * data)\n    Pe = np.sum(column_sums) @ np.sum(row_sums) / total_sum @ weight\n    \n    weighted_kappa = 1 - (P0 / Pe)\n    \n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    data_matrix = np.array(testData)\n    weight_matrix = np.array(w)\n\n    col_sums = np.sum(data_matrix, axis=0)\n    row_sums = np.sum(data_matrix, axis=1)\n    total_sum = np.sum(data_matrix)\n\n    P0 = np.sum(np.multiply(weight_matrix, data_matrix))\n\n    Pe = np.sum(col_sums) * np.sum(row_sums) / total_sum\n    Pe = np.sum(np.multiply(weight_matrix, Pe))\n\n    return 1 - (P0 / Pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        testData = np.array(testData, dtype=int)\n        w = np.array(w)\n        col_sums = np.sum(testData, axis=0)\n        row_sums = np.sum(testData, axis=1)\n        total_sum = np.sum(testData)\n        P0 = np.sum(w * testData)\n        Pe = np.sum(row_sums) * np.sum(col_sums) / total_sum\n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    total_sum = np.sum(testData)\n    P0 = np.sum(w * testData)\n    Pe = np.sum(col_sums) * np.sum(row_sums) / total_sum * w\n    weighted_kappa = 1 - P0 / Pe\n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    numerical_matrix = np.zeros(testData.shape)\n    for i in range(k):\n        for j in range(k):\n            numerical_matrix[testData == i] = j\n\n    weight_matrix = np.zeros((k, k))\n    for i in range(k):\n        for j in range(k):\n            weight_matrix[i, j] = w[i, j]\n\n    total_sum = np.sum(numerical_matrix)\n    row_sums = np.sum(numerical_matrix, axis=1)\n    column_sums = np.sum(numerical_matrix, axis=0)\n\n    P0 = np.sum(numerical_matrix * weight_matrix)\n    Pe = np.sum(row_sums * column_sums) / total_sum\n\n    weighted_kappa = 1 - (P0 / Pe)\n\n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    total_sum = np.sum(testData)\n    row_sum = np.sum(testData, axis=1)\n    column_sum = np.sum(testData, axis=0)\n    P0 = np.sum(testData * w)\n    Pe = np.sum(np.dot(row_sum, column_sum) * w) / total_sum\n    return 1 - (P0 / Pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    \n    N = np.sum(testData)\n    n = testData.shape[0]\n    \n    row_sum = np.sum(testData, axis=1)\n    col_sum = np.sum(testData, axis=0)\n    \n    P0 = np.sum(testData * w)\n    Pe = np.sum(np.sum(row_sum * col_sum) * w) / N\n    \n    return 1 - (P0 / Pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    total_sum = np.sum(testData)\n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    \n    P0 = np.sum(testData * w)\n    Pe = np.sum(row_sums * col_sums) / total_sum\n    \n    return 1 - (P0 / Pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        testData = np.array(testData)\n        w = np.array(w)\n        N = np.sum(testData)\n        n = testData.shape[0]\n        p = np.sum(w, axis=1) / np.sum(w)\n        P0 = np.sum(np.sum(w * testData)) / N\n        Pe = np.sum(np.sum(p ** 2)) / (n ** 2)\n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        testData = np.array(testData)\n        w = np.array(w)\n        row_sums = np.sum(testData, axis=1)\n        col_sums = np.sum(testData, axis=0)\n        total_sum = np.sum(testData)\n        \n        P0 = np.sum(testData * w)\n        \n        Pe = np.sum(np.dot(row_sums, col_sums) / total_sum)\n        \n        weighted_kappa = 1 - (P0 / Pe)\n        \n        return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    total_sum = np.sum(testData)\n    P0 = np.sum(testData * w) / total_sum\n    Pe = np.sum(row_sums * col_sums * w) / (total_sum**2)\n    weighted_kappa = 1 - (P0 / Pe)\n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    \n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    total_sum = np.sum(testData)\n    \n    P0 = np.sum(testData * w)\n    \n    w_row_sums = np.sum(row_sums * w, axis=1)\n    w_col_sums = np.sum(col_sums * w, axis=0)\n    Pe = np.sum(w_row_sums * w_col_sums) / total_sum\n    \n    weighted_kappa = 1 - (P0 / Pe)\n    \n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    \n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    total_sum = np.sum(testData)\n    \n    P0 = np.sum(testData * w)\n    \n    Pe = np.sum(np.outer(row_sums, col_sums) * w) / total_sum\n    \n    weighted_kappa = 1 - (P0 / Pe)\n    \n    return weighted_kappa",
                true
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    total_sum = np.sum(testData)\n    P0 = np.sum(testData * w)\n    Pe = np.sum(np.outer(row_sums, col_sums) * w) / total_sum\n    weighted_kappa = 1 - (P0 / Pe)\n    return weighted_kappa",
                true
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    \n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    total_sum = np.sum(testData)\n    \n    P0 = np.sum(w * testData)\n    Pe = np.sum(col_sums * row_sums) / total_sum\n    \n    weighted_kappa = 1 - (P0 / Pe)\n    \n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n\n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    total_sum = np.sum(testData)\n\n    P0 = np.sum(w * testData)\n    Pe = np.sum(row_sums * col_sums) / total_sum\n\n    weighted_kappa = 1 - P0 / Pe\n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        testData = np.array(testData)\n        w = np.array(w)\n        \n        row_sum = np.sum(testData, axis=1)\n        col_sum = np.sum(testData, axis=0)\n        data_sum = np.sum(testData)\n        \n        P0 = np.sum(w * testData)\n        Pe = (np.sum(col_sum) * np.sum(row_sum) / data_sum) * np.sum(w)\n        \n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        testData = np.array(testData)\n        w = np.array(w)\n        \n        sum_row = np.sum(testData, axis=1)\n        sum_column = np.sum(testData, axis=0)\n        sum_all = np.sum(testData)\n        \n        P0 = np.sum(w * testData)\n        Pe = np.sum(np.sum(sum_column) * sum_row) / sum_all\n        \n        weighted_kappa = 1 - (P0 / Pe)\n        \n        return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    \n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    N = np.sum(testData)\n    \n    P0 = np.sum(w * testData) / N\n    Pe = np.sum(np.sum(col_sums) * np.sum(row_sums) / N) / N\n    \n    weighted_kappa = 1 - (P0 / Pe)\n    \n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    N = np.sum(testData)\n    n = testData.shape[0]\n    P0 = np.sum(testData * w) / N\n    Pe = np.sum(np.sum(testData, axis=0) * np.sum(testData, axis=1) / N) \n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        testData = np.array(testData)\n        w = np.array(w)\n        testData_sum = np.sum(testData)\n        row_sums = np.sum(testData, axis=1)\n        col_sums = np.sum(testData, axis=0)\n        total_sum = np.sum(row_sums)\n        P0 = np.sum(testData * w) / testData_sum\n        Pe = np.sum(row_sums * col_sums) / (total_sum ** 2)\n        weighted_kappa = 1 - (P0 / Pe)\n        return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        testData_num = np.array(testData)\n        w_num = np.array(w)\n        row_sums = np.sum(testData_num, axis=1)\n        col_sums = np.sum(testData_num, axis=0)\n        N = np.sum(testData_num)\n        P0 = np.sum(testData_num * w_num) / N\n        Pe = np.sum(row_sums * col_sums) / (N * N)\n        return 1 - (P0 / Pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        matrix_test = np.array(testData)\n        matrix_weight = np.array(w)\n\n        row_sums = np.sum(matrix_test, axis=1)\n        column_sums = np.sum(matrix_test, axis=0)\n        total_sum = np.sum(matrix_test)\n\n        P0 = np.sum(matrix_test * matrix_weight) / total_sum\n\n        Pe = np.dot(row_sums, column_sums) / (total_sum ** 2)\n\n        weighted_kappa = 1 - (P0 / Pe)\n\n        return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n\n    row_sum = np.sum(testData, axis=1)\n    col_sum = np.sum(testData, axis=0)\n    matrix_sum = np.sum(testData)\n\n    P0 = np.sum(np.multiply(testData, w)) / matrix_sum\n    Pe = np.sum(np.multiply(row_sum, col_sum)) / (matrix_sum * matrix_sum)\n\n    weighted_kappa = 1 - (P0 / Pe)\n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    \n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    total_sum = np.sum(testData)\n    \n    P0 = np.sum(testData * w)\n    \n    Pe = np.sum(row_sums * col_sums) / (total_sum * np.sum(w))\n    \n    weighted_kappa = 1 - (P0 / Pe)\n    \n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    total_sum = np.sum(testData)\n    P0 = np.sum(testData * w)\n    Pe = np.sum(row_sums * col_sums) / (total_sum * np.sum(w))\n    weighted_kappa = 1 - (P0 / Pe)\n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        testData = np.array(testData)\n        w = np.array(w)\n        row_sums = np.sum(testData, axis=1)\n        col_sums = np.sum(testData, axis=0)\n        total_sum = np.sum(testData)\n        P0 = np.sum(testData * w)\n        Pe = np.sum(row_sums * col_sums) / (total_sum * total_sum) * np.sum(w)\n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    testData = np.array(testData)\n    w = np.array(w)\n    \n    row_sums = np.sum(testData, axis=1)\n    col_sums = np.sum(testData, axis=0)\n    total_sum = np.sum(testData)\n    \n    P0 = np.sum(testData * w)\n    Pe = np.sum(np.outer(row_sums, col_sums) / total_sum * w)\n    \n    return 1 - P0 / Pe",
                true
            ],
            [
                "def kappa_weighted(testData, k, w):\n        testData = np.array(testData)\n        w = np.array(w)\n\n        row_sums = np.sum(testData, axis=1)\n        col_sums = np.sum(testData, axis=0)\n        total = np.sum(testData)\n\n        P0 = np.sum(testData * w)\n        Pe = np.sum((row_sums * col_sums) / total) * np.sum(w)\n\n        weighted_kappa = 1 - (P0 / Pe)\n        return weighted_kappa",
                false
            ]
        ],
        "level 3": [
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weights = np.array(w)\n    xsum = dataMat.sum(axis=1)\n    ysum = dataMat.sum(axis=0)\n    total_sum = dataMat.sum()\n    P0 = np.dot(weights, dataMat)\n    Pe = np.dot(ysum.T, xsum) / total_sum\n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weights = np.array(w)\n    \n    xsum = np.sum(dataMat, axis=1)\n    ysum = np.sum(dataMat, axis=0)\n    total_sum = np.sum(dataMat)\n    \n    P0 = np.dot(weights, dataMat)\n    \n    Pe = np.dot(ysum.reshape(-1, 1), xsum.reshape(1, -1)) / total_sum\n    Pe = np.dot(Pe, weights)\n    \n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weightMat = np.array(w)\n    xsum = dataMat.sum(axis=1)\n    ysum = dataMat.sum(axis=0)\n    total_sum = dataMat.sum()\n    P0 = np.dot(weightMat, dataMat)\n    Pe = np.dot(ysum.reshape(-1,1), xsum.reshape(1,-1)) / total_sum\n    Pe = np.dot(Pe, weightMat)\n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.array(testData)\n        wMat = np.array(w)\n\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        total_sum = np.sum(dataMat)\n\n        P0 = np.dot(wMat, dataMat)\n        Pe = np.dot(ysum.reshape(-1, 1), xsum.reshape(1, -1)) / total_sum\n        Pe = np.dot(Pe, wMat)\n\n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weightMat = np.array(w)\n    xsum = dataMat.sum(axis=1)\n    ysum = dataMat.sum(axis=0)\n    sum_all = dataMat.sum()\n    P0 = np.dot(weightMat, dataMat)\n    Pe = np.dot(ysum.reshape(-1, 1), xsum.reshape(1, -1)) / sum_all\n    Pw = np.dot(weightMat, Pe)\n    kappa_weighted = 1 - P0.sum() / Pw.sum()\n    return kappa_weighted",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weights = np.array(w)\n    xsum = dataMat.sum(axis=1)\n    ysum = dataMat.sum(axis=0)\n    sum_all = dataMat.sum()\n    P0 = np.dot(dataMat, weights)\n    Pe = np.dot(ysum, xsum) / sum_all\n    Pe = np.dot(Pe, weights)\n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.array(testData)\n        weights = np.array(w)\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        total_sum = np.sum(dataMat)\n        P0 = np.dot(dataMat, weights)\n        Pe = np.dot(ysum.T, xsum) / total_sum\n        Pe = np.dot(Pe, weights)\n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weights = np.array(w)\n    xsum = np.sum(dataMat, axis=1)\n    ysum = np.sum(dataMat, axis=0)\n    total = np.sum(dataMat)\n    P0 = np.dot(dataMat, weights)\n    Pe = np.dot(ysum.T, xsum) / total\n    Pe = np.dot(Pe, weights)\n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.array(testData)\n        weightMat = np.array(w)\n        xsum = dataMat.sum(axis=1)\n        ysum = dataMat.sum(axis=0)\n        total = dataMat.sum()\n\n        P0 = np.dot(dataMat, weightMat)\n        Pe = np.dot(ysum, xsum) / total\n        Pe = np.dot(Pe, weightMat)\n\n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weights = np.array(w)\n    xsum = dataMat.sum(axis=1)\n    ysum = dataMat.sum(axis=0)\n    total = dataMat.sum()\n    P0 = np.dot(dataMat, weights)\n    Pe = np.dot(ysum, xsum) / total * np.dot(weights)\n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.array(testData)\n        weightMat = np.array(w)\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        total = np.sum(dataMat)\n        P0 = np.dot(weightMat, dataMat)\n        Pe = np.dot(np.dot(np.transpose(ysum), xsum) / total, weightMat)\n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.array(testData)\n        dataW = np.array(w)\n        xsum = dataMat.sum(axis=1)\n        ysum = dataMat.sum(axis=0)\n        sum = dataMat.sum()\n        P0 = np.dot(w, dataMat)\n        Pe = np.dot(ysum[:, np.newaxis], xsum[np.newaxis, :]) / sum\n        Pe = np.dot(Pe, w)\n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    w = np.array(w)\n    \n    xsum = dataMat.sum(axis=1)\n    ysum = dataMat.sum(axis=0)\n    total = dataMat.sum()\n    \n    P0 = np.dot(w, dataMat)\n    \n    Pe = np.dot(ysum.T, xsum) / total\n    Pe = np.dot(Pe, w)\n    \n    weighted_kappa = 1 - P0 / Pe\n    \n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.array(testData)\n        weight = np.array(w)\n        xsum = dataMat.sum(axis=1)\n        ysum = dataMat.sum(axis=0)\n        sum = dataMat.sum()\n        P0 = np.dot(weight, dataMat)\n        Pe = np.dot(ysum[:, np.newaxis], xsum[np.newaxis, :]) / sum\n        Pe = np.dot(Pe, weight)\n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weightMat = np.array(w)\n    xsum = dataMat.sum(axis=1)\n    ysum = dataMat.sum(axis=0)\n    total = dataMat.sum()\n    P0 = np.dot(weightMat, dataMat).sum() / total\n    Pe = np.dot(ysum[:, np.newaxis], xsum[np.newaxis, :]).sum() / total\n    Pe = np.dot(np.dot(ysum[:, np.newaxis], xsum[np.newaxis, :]), weightMat).sum() / total\n    weighted_kappa = 1 - P0 / Pe\n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.matrix(testData)\n        w = np.array(w)\n        xsum = dataMat.sum(axis=1)\n        ysum = dataMat.sum(axis=0)\n        total_sum = dataMat.sum()\n        P0 = np.dot(w, dataMat)\n        Pe = np.dot(np.transpose(ysum), xsum) / total_sum * w\n        weighted_kappa = 1 - P0 / Pe\n        return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.matrix(testData)\n        w = np.array(w)\n        xsum = np.sum(dataMat, axis=0)\n        ysum = np.sum(dataMat, axis=1)\n        total_sum = np.sum(dataMat)\n        \n        P0 = np.dot(w, dataMat)\n        \n        Pe = np.dot(np.transpose(ysum), xsum) / total_sum * w\n        \n        weighted_kappa = 1 - P0 / Pe\n        return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.matrix(testData)\n    w = np.array(w)\n    xsum = dataMat.sum(axis=1)\n    ysum = dataMat.sum(axis=0)\n    sum = dataMat.sum()\n    P0 = np.dot(w, dataMat)\n    Pe = np.dot(ysum.T, xsum) / sum * w\n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.matrix(testData)\n        w = np.array(w)\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        total_sum = np.sum(dataMat)\n        P0 = np.dot(w, dataMat)\n        Pe = np.dot(ysum.T, xsum) / total_sum * w\n        weighted_kappa = 1 - P0 / Pe\n        return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.matrix(testData)\n    w = np.array(w)\n    xsum = dataMat.sum(axis=1)\n    ysum = dataMat.sum(axis=0)\n    total_sum = dataMat.sum()\n    P0 = np.dot(w, dataMat)\n    Pe = np.dot(ysum.T, xsum) / total_sum * w\n    weighted_kappa = 1 - P0 / Pe\n    return weighted_kappa",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.matrix(testData)\n        wMat = np.matrix(w)\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        totalSum = np.sum(dataMat)\n        P0 = np.dot(wMat, dataMat).trace() / totalSum\n        Pe = (np.dot(np.transpose(ysum), xsum) / totalSum).trace()\n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.matrix(testData)\n        weightMat = np.matrix(w)\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        sumTotal = np.sum(dataMat)\n        P0 = np.dot(weightMat, dataMat).diagonal().sum() / sumTotal\n        Pe = np.dot(ysum.T, xsum) / (sumTotal * sumTotal) * np.dot(weightMat, np.dot(ysum.T, xsum))\n        return 1 - (P0 / Pe)",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n        dataMat = np.matrix(testData)\n        wMat = np.matrix(w)\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        sum_all = np.sum(dataMat)\n        P0 = np.dot(wMat, dataMat).diagonal().sum() / sum_all\n        Pe = np.dot(np.transpose(ysum), xsum) / sum_all\n        return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.matrix(testData)\n    wMat = np.matrix(w)\n\n    xsum = dataMat.sum(axis=1).A.flatten()\n    ysum = dataMat.sum(axis=0).A.flatten()\n    sum_all = dataMat.sum()\n\n    P0 = np.dot(wMat, dataMat).trace() / sum_all\n    Pe = np.dot(ysum, xsum) / (sum_all ** 2) * np.dot(wMat, wMat.T).trace()\n\n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.matrix(testData)\n    wMat = np.matrix(w)\n\n    xsum = np.sum(dataMat, axis=1)\n    ysum = np.sum(dataMat, axis=0)\n    totalSum = np.sum(dataMat)\n\n    P0 = np.dot(wMat, dataMat).diagonal().sum() / totalSum\n    \n    Pe = np.dot(ysum.T, xsum) / totalSum\n    Pe = np.dot(Pe, wMat).diagonal().sum()\n\n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weightMat = np.array(w)\n    xsum = np.sum(dataMat, axis=1)\n    ysum = np.sum(dataMat, axis=0)\n    totalSum = np.sum(dataMat)\n    \n    P0 = np.dot(weightMat, dataMat)\n    \n    Pe = np.dot(ysum.T, xsum) * totalSum\n    Pe = np.dot(Pe, weightMat)\n    \n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weightMat = np.array(w)\n    \n    xsum = np.sum(dataMat, axis=1)\n    ysum = np.sum(dataMat, axis=0)\n    total_sum = np.sum(dataMat)\n    \n    P0 = np.dot(weightMat, dataMat)\n    \n    Pe = np.dot(ysum.T, xsum) * total_sum\n    Pe = np.dot(Pe, weightMat)\n    \n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weightMat = np.array(w)\n    \n    xsum = np.sum(dataMat, axis=1)\n    ysum = np.sum(dataMat, axis=0)\n    \n    sumValues = np.sum(dataMat)\n    \n    P0 = np.dot(weightMat, dataMat)\n    \n    Pe = np.dot(ysum.T, xsum) * sumValues\n    \n    Pe = np.dot(Pe, weightMat)\n    \n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    weight = np.array(w)\n    \n    xsum = dataMat.sum(axis=1)\n    ysum = dataMat.sum(axis=0)\n    \n    total_sum = dataMat.sum()\n    \n    P0 = np.dot(weight, dataMat).sum() / total_sum\n    Pe = np.dot(ysum[:, np.newaxis], xsum[np.newaxis, :]) / total_sum\n    Pe = np.dot(Pe.ravel(), weight.ravel())\n    \n    return 1 - P0 / Pe",
                false
            ],
            [
                "def kappa_weighted(testData, k, w):\n    dataMat = np.array(testData)\n    w = np.array(w)\n    xsum = dataMat.sum(axis=1)\n    ysum = dataMat.sum(axis=0)\n    total = dataMat.sum()\n    P0 = np.dot(w, dataMat).sum() / total\n    Pe = np.dot(ysum.T, xsum) / total\n    Pe = np.dot(Pe, w)\n    return 1 - P0 / Pe",
                false
            ]
        ]
    },
    "1": {
        "level 1": [
            [
                "def correlation_coefficient_rank(data1, data2):\n    rank_data1 = {value: i+1 for i, value in enumerate(sorted(data1))}\n    rank_data2 = {value: i+1 for i, value in enumerate(sorted(data2))}\n    \n    sum_x_sq = sum([rank_data1[i] ** 2 for i in data1])\n    sum_y_sq = sum([rank_data2[i] ** 2 for i in data2])\n    sum_xy = sum([rank_data1[data1[i]] * rank_data2[data2[i]] for i in range(len(data1))])\n    \n    n = len(data1)\n    correlation_coefficient = (n * sum_xy - sum(rank_data1.values()) * sum(rank_data2.values())) / math.sqrt((n * sum_x_sq - sum(rank_data1.values()) ** 2) * (n * sum_y_sq - sum(rank_data2.values()) ** 2))\n    \n    return correlation_coefficient",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    data1_rank = {value: i+1 for i, value in enumerate(sorted(data1))}\n    data2_rank = {value: i+1 for i, value in enumerate(sorted(data2))}\n    n = len(data1)\n    sum_rank_data1 = sum(data1_rank[value] for value in data1)\n    sum_rank_data2 = sum(data2_rank[value] for value in data2)\n    sum_rank_data1_sq = sum(rank**2 for rank in data1_rank.values())\n    sum_rank_data2_sq = sum(rank**2 for rank in data2_rank.values())\n    sum_rank_data1_data2 = sum(data1_rank[data1[i]] * data2_rank[data2[i]] for i in range(n))\n    correlation_coefficient_rank = (n * sum_rank_data1_data2 - sum_rank_data1 * sum_rank_data2) / math.sqrt((n * sum_rank_data1_sq - sum_rank_data1**2) * (n * sum_rank_data2_sq - sum_rank_data2**2))\n    return correlation_coefficient_rank",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank_data1 = [sorted(data1).index(i) for i in data1]\n        rank_data2 = [sorted(data2).index(i) for i in data2]\n        n = len(data1)\n        \n        sum_rank_data1 = sum(rank_data1)\n        sum_rank_data2 = sum(rank_data2)\n        sum_product_ranks = sum([rank_data1[i] * rank_data2[i] for i in range(n)])\n        sum_square_rank_data1 = sum([rank_data1[i] ** 2 for i in range(n)])\n        sum_square_rank_data2 = sum([rank_data2[i] ** 2 for i in range(n)])\n        \n        correlation_coefficient_rank = (n * sum_product_ranks - sum_rank_data1 * sum_rank_data2) / math.sqrt((n * sum_square_rank_data1 - sum_rank_data1 ** 2) * (n * sum_square_rank_data2 - sum_rank_data2 ** 2))\n        \n        return correlation_coefficient_rank",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        data1_rank = [sorted(data1).index(x) for x in data1]\n        data2_rank = [sorted(data2).index(x) for x in data2]\n        \n        n = len(data1)\n        sum_data1_rank = sum(data1_rank)\n        sum_data2_rank = sum(data2_rank)\n        sum_data1_rank_sq = sum([rank ** 2 for rank in data1_rank])\n        sum_data2_rank_sq = sum([rank ** 2 for rank in data2_rank])\n        sum_product_rank = sum([data1_rank[i] * data2_rank[i] for i in range(n)])\n        \n        numerator = n * sum_product_rank - sum_data1_rank * sum_data2_rank\n        denominator = math.sqrt((n * sum_data1_rank_sq - sum_data1_rank ** 2) * (n * sum_data2_rank_sq - sum_data2_rank ** 2))\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank_data1 = [sorted(data1).index(i) + 1 for i in data1]\n        rank_data2 = [sorted(data2).index(i) + 1 for i in data2]\n        n = len(data1)\n        sum_rank_data1 = sum(rank_data1)\n        sum_rank_data2 = sum(rank_data2)\n        sum_rank_data1_sq = sum([r ** 2 for r in rank_data1])\n        sum_rank_data2_sq = sum([r ** 2 for r in rank_data2])\n        sum_rank_data1_data2 = sum([a * b for a, b in zip(rank_data1, rank_data2)])\n        numerator = n * sum_rank_data1_data2 - sum_rank_data1 * sum_rank_data2\n        denominator = math.sqrt((n * sum_rank_data1_sq - sum_rank_data1 ** 2) * (n * sum_rank_data2_sq - sum_rank_data2 ** 2))\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x) for x in data1]\n        ranked_data2 = [sorted(data2).index(x) for x in data2]\n        \n        n = len(data1)\n        \n        sum_ranked_data1 = sum(ranked_data1)\n        sum_ranked_data2 = sum(ranked_data2)\n        \n        sum_squared_ranked_data1 = sum([x**2 for x in ranked_data1])\n        sum_squared_ranked_data2 = sum([x**2 for x in ranked_data2])\n        \n        product_sum_ranked_data = sum([x*y for x, y in zip(ranked_data1, ranked_data2)])\n        \n        numerator = n * product_sum_ranked_data - sum_ranked_data1 * sum_ranked_data2\n        denominator = math.sqrt((n * sum_squared_ranked_data1 - sum_ranked_data1**2) * (n * sum_squared_ranked_data2 - sum_ranked_data2**2))\n        \n        if denominator == 0:\n            return 0.0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    ranked_data1 = [sorted(data1).index(i) + 1 for i in data1]\n    ranked_data2 = [sorted(data2).index(i) + 1 for i in data2]\n    n = len(data1)\n    sum_ranked_data1 = sum(ranked_data1)\n    sum_ranked_data2 = sum(ranked_data2)\n    sum_ranked_data1_sq = sum([x**2 for x in ranked_data1])\n    sum_ranked_data2_sq = sum([x**2 for x in ranked_data2])\n    sum_ranked_data1_data2 = sum([x*y for x, y in zip(ranked_data1, ranked_data2)])\n    \n    correlation = (n*sum_ranked_data1_data2 - sum_ranked_data1*sum_ranked_data2) / math.sqrt((n*sum_ranked_data1_sq - sum_ranked_data1**2) * (n*sum_ranked_data2_sq - sum_ranked_data2**2))\n    return correlation",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = sorted(data1)\n        ranked_data2 = sorted(data2)\n        n = len(data1)\n        rank_sum1 = sum([ranked_data1.index(d) + 1 for d in data1])\n        rank_sum2 = sum([ranked_data2.index(d) + 1 for d in data2])\n        rank_squared_sum1 = sum([(ranked_data1.index(d) + 1) ** 2 for d in data1])\n        rank_squared_sum2 = sum([(ranked_data2.index(d) + 1) ** 2 for d in data2])\n        correlation = (n * (rank_sum1 * rank_sum2) - rank_squared_sum1 * rank_squared_sum2) / math.sqrt((n * rank_squared_sum1 - rank_sum1 ** 2) * (n * rank_squared_sum2 - rank_sum2 ** 2))\n        return correlation",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        data1_rank = sorted(data1)\n        data2_rank = sorted(data2)\n        n = len(data1)\n        rank_data1 = [data1_rank.index(i) + 1 for i in data1]\n        rank_data2 = [data2_rank.index(i) + 1 for i in data2]\n        sum_rank_data1 = sum(rank_data1)\n        sum_rank_data2 = sum(rank_data2)\n        sum_rank_data1_sq = sum([rank ** 2 for rank in rank_data1])\n        sum_rank_data2_sq = sum([rank ** 2 for rank in rank_data2])\n        \n        numerator = n * sum([rank_data1[i] * rank_data2[i] for i in range(n)]) - sum_rank_data1 * sum_rank_data2\n        denominator = math.sqrt((n * sum_rank_data1_sq - sum_rank_data1 ** 2) * (n * sum_rank_data2_sq - sum_rank_data2 ** 2))\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        def rank(data):\n            ranked_data = {value: i + 1 for i, value in enumerate(sorted(data))}\n            return [ranked_data[value] for value in data]\n\n        n = len(data1)\n        ranked_data1 = rank(data1)\n        ranked_data2 = rank(data2)\n\n        sum_ranked_data1 = sum(ranked_data1)\n        sum_ranked_data2 = sum(ranked_data2)\n        sum_ranked_data1_sq = sum(rank ** 2 for rank in ranked_data1)\n        sum_ranked_data2_sq = sum(rank ** 2 for rank in ranked_data2)\n        sum_ranked_data1_data2 = sum(rank1 * rank2 for rank1, rank2 in zip(ranked_data1, ranked_data2))\n\n        numerator = n * sum_ranked_data1_data2 - sum_ranked_data1 * sum_ranked_data2\n        denominator = math.sqrt((n * sum_ranked_data1_sq - sum_ranked_data1 ** 2) * (n * sum_ranked_data2_sq - sum_ranked_data2 ** 2))\n\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        data1_rank = {val: i+1 for i, val in enumerate(sorted(data1))}\n        data2_rank = {val: i+1 for i, val in enumerate(sorted(data2))}\n        n = len(data1)\n        rank_data1_sum = sum(data1_rank[val] for val in data1)\n        rank_data2_sum = sum(data2_rank[val] for val in data2)\n        rank_data1_data2_sum = sum(data1_rank[data1[i]] * data2_rank[data2[i]] for i in range(n))\n        rank_data1_squared_sum = sum(data1_rank[val] ** 2 for val in data1)\n        rank_data2_squared_sum = sum(data2_rank[val] ** 2 for val in data2)\n\n        correlation_coefficient = (n * rank_data1_data2_sum - rank_data1_sum * rank_data2_sum) / math.sqrt((n * rank_data1_squared_sum - rank_data1_sum ** 2) * (n * rank_data2_squared_sum - rank_data2_sum ** 2))\n        return correlation_coefficient",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    data1_rank = [sorted(data1).index(i) for i in data1]\n    data2_rank = [sorted(data2).index(i) for i in data2]\n    \n    n = len(data1)\n    sum_data1_rank = sum(data1_rank)\n    sum_data2_rank = sum(data2_rank)\n    sum_data1_rank_sq = sum([rank ** 2 for rank in data1_rank])\n    sum_data2_rank_sq = sum([rank ** 2 for rank in data2_rank])\n    sum_data1_data2_rank = sum([data1_rank[i] * data2_rank[i] for i in range(n)])\n    \n    correlation = (n * sum_data1_data2_rank - sum_data1_rank * sum_data2_rank) / math.sqrt((n * sum_data1_rank_sq - sum_data1_rank ** 2) * (n * sum_data2_rank_sq - sum_data2_rank ** 2))\n    \n    return correlation",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        data1_rank = [sorted(data1).index(x) for x in data1]\n        data2_rank = [sorted(data2).index(x) for x in data2]\n        n = len(data1)\n\n        sum_data1 = sum(data1_rank)\n        sum_data2 = sum(data2_rank)\n        sum_data1_sq = sum([x**2 for x in data1_rank])\n        sum_data2_sq = sum([x**2 for x in data2_rank])\n        sum_data1_data2 = sum([data1_rank[i]*data2_rank[i] for i in range(n)])\n\n        correlation = (n*sum_data1_data2 - sum_data1*sum_data2) / math.sqrt((n*sum_data1_sq - sum_data1**2) * (n*sum_data2_sq - sum_data2**2))\n\n        return correlation",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        data1_rank = [sorted(data1).index(x) for x in data1]\n        data2_rank = [sorted(data2).index(x) for x in data2]\n        n = len(data1)\n        sum_data1_rank = sum(data1_rank)\n        sum_data2_rank = sum(data2_rank)\n        sum_data1_rank_sq = sum([x ** 2 for x in data1_rank])\n        sum_data2_rank_sq = sum([x ** 2 for x in data2_rank])\n        sum_data1_data2_rank = sum([data1_rank[i] * data2_rank[i] for i in range(n)])\n        \n        correlation_coefficient = (n * sum_data1_data2_rank - sum_data1_rank * sum_data2_rank) / math.sqrt((n * sum_data1_rank_sq - sum_data1_rank ** 2) * (n * sum_data2_rank_sq - sum_data2_rank ** 2))\n        \n        return correlation_coefficient",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    data1_rank = [sorted(data1).index(x) for x in data1]\n    data2_rank = [sorted(data2).index(x) for x in data2]\n    \n    n = len(data1)\n    sum_data1 = sum(data1_rank)\n    sum_data2 = sum(data2_rank)\n    sum_squares_data1 = sum([x**2 for x in data1_rank])\n    sum_squares_data2 = sum([x**2 for x in data2_rank])\n    sum_product = sum([a*b for a, b in zip(data1_rank, data2_rank)])\n    \n    correlation_coefficient = (n*sum_product - sum_data1*sum_data2) / math.sqrt((n*sum_squares_data1 - sum_data1**2) * (n*sum_squares_data2 - sum_data2**2))\n    \n    return correlation_coefficient",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    data1_rank = {value: i + 1 for i, value in enumerate(sorted(data1))}\n    data2_rank = {value: i + 1 for i, value in enumerate(sorted(data2))}\n    n = len(data1)\n    \n    sum_x_sq = sum([rank**2 for rank in data1_rank.values()])\n    sum_y_sq = sum([rank**2 for rank in data2_rank.values()])\n    sum_xy = sum(data1_rank[value] * data2_rank[value] for value in set(data1) & set(data2))\n    \n    correlation_coef = (n * sum_xy - sum(data1_rank.values()) * sum(data2_rank.values())) / math.sqrt((n * sum_x_sq - sum(data1_rank.values())**2) * (n * sum_y_sq - sum(data2_rank.values())**2))\n    \n    return correlation_coef",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank_data1 = {value: i+1 for i, value in enumerate(sorted(data1))}\n        rank_data2 = {value: i+1 for i, value in enumerate(sorted(data2))}\n        n = len(data1)\n        sum_rank_data1 = sum(rank_data1[value] for value in data1)\n        sum_rank_data2 = sum(rank_data2[value] for value in data2)\n        sum_rank_data1_sq = sum(rank_data1[value]**2 for value in data1)\n        sum_rank_data2_sq = sum(rank_data2[value]**2 for value in data2)\n        sum_rank_data1_data2 = sum(rank_data1[data1[i]] * rank_data2[data2[i]] for i in range(n))\n        \n        numerator = n * sum_rank_data1_data2 - sum_rank_data1 * sum_rank_data2\n        denominator = math.sqrt((n * sum_rank_data1_sq - sum_rank_data1**2) * (n * sum_rank_data2_sq - sum_rank_data2**2))\n        \n        correlation_coefficient = numerator / denominator\n        return correlation_coefficient",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank_data1 = [sorted(data1).index(i) for i in data1]\n        rank_data2 = [sorted(data2).index(i) for i in data2]\n        n = len(data1)\n        sum_rank_data1 = sum(rank_data1)\n        sum_rank_data2 = sum(rank_data2)\n        sum_rank_data1_sq = sum([i**2 for i in rank_data1])\n        sum_rank_data2_sq = sum([i**2 for i in rank_data2])\n        sum_rank_data1_data2 = sum([rank_data1[i] * rank_data2[i] for i in range(n)])\n        numerator = n * sum_rank_data1_data2 - sum_rank_data1 * sum_rank_data2\n        denominator = math.sqrt((n*sum_rank_data1_sq - sum_rank_data1**2) * (n*sum_rank_data2_sq - sum_rank_data2**2))\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank_data1 = [sorted(data1).index(i)+1 for i in data1]\n        rank_data2 = [sorted(data2).index(i)+1 for i in data2]\n        n = len(data1)\n        sum_rank_data1 = sum(rank_data1)\n        sum_rank_data2 = sum(rank_data2)\n        sum_rank_data1_sq = sum([r ** 2 for r in rank_data1])\n        sum_rank_data2_sq = sum([r ** 2 for r in rank_data2])\n        sum_product_ranks = sum([rank_data1[i] * rank_data2[i] for i in range(n)])\n        \n        correlation_coefficient = (n * sum_product_ranks - sum_rank_data1 * sum_rank_data2) / math.sqrt((n * sum_rank_data1_sq - sum_rank_data1 ** 2) * (n * sum_rank_data2_sq - sum_rank_data2 ** 2))\n        \n        return correlation_coefficient",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    rank_data1 = {value: i + 1 for i, value in enumerate(sorted(data1))}\n    rank_data2 = {value: i + 1 for i, value in enumerate(sorted(data2))}\n    n = len(data1)\n    sum_rank_data1 = sum(rank_data1[value] for value in data1)\n    sum_rank_data2 = sum(rank_data2[value] for value in data2)\n    sum_rank_data1_sq = sum(rank_data1[value] ** 2 for value in data1)\n    sum_rank_data2_sq = sum(rank_data2[value] ** 2 for value in data2)\n    sum_rank_product = sum(rank_data1[value] * rank_data2[value] for value in data1)\n\n    correlation_coefficient = (n * sum_rank_product - sum_rank_data1 * sum_rank_data2) / math.sqrt((n * sum_rank_data1_sq - sum_rank_data1 ** 2) * (n * sum_rank_data2_sq - sum_rank_data2 ** 2))\n    return correlation_coefficient",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    rank_data1 = [sorted(data1).index(i) + 1 for i in data1]\n    rank_data2 = [sorted(data2).index(i) + 1 for i in data2]\n    \n    n = len(data1)\n    sum_rank_data1 = sum(rank_data1)\n    sum_rank_data2 = sum(rank_data2)\n    sum_rank_data1_sq = sum([rank ** 2 for rank in rank_data1])\n    sum_rank_data2_sq = sum([rank ** 2 for rank in rank_data2])\n    sum_rank_data1_data2 = sum([r1 * r2 for r1, r2 in zip(rank_data1, rank_data2)])\n    \n    correlation = (n * sum_rank_data1_data2 - sum_rank_data1 * sum_rank_data2) / math.sqrt((n * sum_rank_data1_sq - sum_rank_data1 ** 2) * (n * sum_rank_data2_sq - sum_rank_data2 ** 2))\n    \n    return correlation",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        data1_rank = [sorted(data1).index(i) for i in data1]\n        data2_rank = [sorted(data2).index(i) for i in data2]\n        n = len(data1)\n        numerator = sum((data1_rank[i] - (n - 1) / 2) * (data2_rank[i] - (n - 1) / 2) for i in range(n))\n        denominator = math.sqrt(sum((data1_rank[i] - (n - 1) / 2) ** 2 for i in range(n)) * sum((data2_rank[i] - (n - 1) / 2) ** 2 for i in range(n)))\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    data1_rank = {value: i+1 for i, value in enumerate(sorted(data1))}\n    data2_rank = {value: i+1 for i, value in enumerate(sorted(data2))}\n    n = len(data1)\n    sum_data1_rank = sum(data1_rank[value] for value in data1)\n    sum_data2_rank = sum(data2_rank[value] for value in data2)\n    sum_product_ranks = sum(data1_rank[data1[i]] * data2_rank[data2[i]] for i in range(n))\n    sum_squared_data1_rank = sum(rank**2 for rank in data1_rank.values())\n    sum_squared_data2_rank = sum(rank**2 for rank in data2_rank.values())\n\n    numerator = n * sum_product_ranks - sum_data1_rank * sum_data2_rank\n    denominator = math.sqrt((n * sum_squared_data1_rank - sum_data1_rank**2) * (n * sum_squared_data2_rank - sum_data2_rank**2))\n\n    return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    data1_rank = [sorted(data1).index(i) for i in data1]\n    data2_rank = [sorted(data2).index(i) for i in data2]\n    n = len(data1)\n    sum_data1_rank = sum(data1_rank)\n    sum_data2_rank = sum(data2_rank)\n    sum_data1_rank_sq = sum(i ** 2 for i in data1_rank)\n    sum_data2_rank_sq = sum(i ** 2 for i in data2_rank)\n    sum_data1_data2_rank = sum(data1_rank[i] * data2_rank[i] for i in range(n))\n    \n    correlation = (n * sum_data1_data2_rank - sum_data1_rank * sum_data2_rank) / math.sqrt((n * sum_data1_rank_sq - sum_data1_rank ** 2) * (n * sum_data2_rank_sq - sum_data2_rank ** 2))\n    \n    return correlation",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    rank_data1 = [sorted(data1).index(i) + 1 for i in data1]\n    rank_data2 = [sorted(data2).index(i) + 1 for i in data2]\n    \n    n = len(data1)\n    \n    sum_rank_data1 = sum(rank_data1)\n    sum_rank_data2 = sum(rank_data2)\n    \n    sum_rank_data1_sq = sum([rank**2 for rank in rank_data1])\n    sum_rank_data2_sq = sum([rank**2 for rank in rank_data2])\n    \n    sum_rank_data1_rank_data2 = sum([rank_data1[i] * rank_data2[i] for i in range(n)])\n    \n    numerator = n * sum_rank_data1_rank_data2 - sum_rank_data1 * sum_rank_data2\n    denominator = math.sqrt((n * sum_rank_data1_sq - sum_rank_data1**2) * (n * sum_rank_data2_sq - sum_rank_data2**2))\n    \n    return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    n = len(data1)\n    data1_rank = {val: i+1 for i, val in enumerate(sorted(data1))}\n    data2_rank = {val: i+1 for i, val in enumerate(sorted(data2))}\n    \n    d = sum((data1_rank[data1[i]] - data2_rank[data2[i]]) ** 2 for i in range(n))\n    rank_corr_coeff = 1 - (6 * d) / (n * (n**2 - 1))\n    \n    return rank_corr_coeff",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        n = len(data1)\n        data1_rank = [sorted(data1).index(i) + 1 for i in data1]\n        data2_rank = [sorted(data2).index(j) + 1 for j in data2]\n        \n        sum_differences_squared = sum((data1_rank[i] - data2_rank[i])**2 for i in range(n))\n        \n        return 1 - (6 * sum_differences_squared) / (n * (n**2 - 1))",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        n = len(data1)\n        data1_rank = [sorted(data1).index(x) for x in data1]\n        data2_rank = [sorted(data2).index(x) for x in data2]\n        diff_rank_squared = [(data1_rank[i] - data2_rank[i])**2 for i in range(n)]\n        return 1 - (6 * sum(diff_rank_squared)) / (n * (n**2 - 1))",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        n = len(data1)\n        data1_rank = [sorted(data1).index(x) for x in data1]\n        data2_rank = [sorted(data2).index(x) for x in data2]\n        diff_square = sum([(data1_rank[i] - data2_rank[i])**2 for i in range(n)])\n        coefficient = 1 - ((6 * diff_square) / (n * (n**2 - 1)))\n        return coefficient",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    n = len(data1)\n    data1_rank = [sorted(data1).index(x) for x in data1]\n    data2_rank = [sorted(data2).index(x) for x in data2]\n    \n    diff_rank_sq = [(data1_rank[i] - data2_rank[i])**2 for i in range(n)]\n    sum_diff_rank_sq = sum(diff_rank_sq)\n    \n    cc_rank = 1 - ((6 * sum_diff_rank_sq) / (n * (n**2 - 1)))\n    \n    return cc_rank",
                false
            ]
        ],
        "level 2": [
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank1 = [sorted(data1).index(x) for x in data1]\n        rank2 = [sorted(data2).index(x) for x in data2]\n        mean_rank1 = sum(rank1) / len(rank1)\n        mean_rank2 = sum(rank2) / len(rank2)\n        \n        numerator = sum((r1 - mean_rank1) * (r2 - mean_rank2) for r1, r2 in zip(rank1, rank2))\n        \n        deviation1 = math.sqrt(sum((r - mean_rank1) ** 2 for r in rank1))\n        deviation2 = math.sqrt(sum((r - mean_rank2) ** 2 for r in rank2))\n        \n        denominator = deviation1 * deviation2\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    rank1 = {value: i for i, value in enumerate(sorted(data1))}\n    rank2 = {value: i for i, value in enumerate(sorted(data2))}\n\n    mean_rank1 = sum(rank1[value] for value in data1) / len(data1)\n    mean_rank2 = sum(rank2[value] for value in data2) / len(data2)\n\n    numerator = sum((rank1[data1[i]] - mean_rank1) * (rank2[data2[i]] - mean_rank2) for i in range(len(data1)))\n    denominator = math.sqrt(sum((rank1[value] - mean_rank1)**2 for value in data1) * sum((rank2[value] - mean_rank2)**2 for value in data2))\n    \n    return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        data1_sorted = sorted(data1)\n        data2_sorted = sorted(data2)\n        n = len(data1)\n        \n        ranks1 = [data1_sorted.index(i) for i in data1]\n        ranks2 = [data2_sorted.index(i) for i in data2]\n        \n        mean_rank1 = sum(ranks1) / n\n        mean_rank2 = sum(ranks2) / n\n        \n        numerator = sum((ranks1[i] - mean_rank1) * (ranks2[i] - mean_rank2) for i in range(n))\n        \n        std_dev1 = math.sqrt(sum((rank - mean_rank1) ** 2 for rank in ranks1))\n        std_dev2 = math.sqrt(sum((rank - mean_rank2) ** 2 for rank in ranks2))\n        \n        denominator = std_dev1 * std_dev2\n        \n        correlation_coefficient = numerator / denominator\n        return correlation_coefficient",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranks1 = [sorted(data1).index(d) for d in data1]\n        ranks2 = [sorted(data2).index(d) for d in data2]\n        mean_rank1 = sum(ranks1) / len(ranks1)\n        mean_rank2 = sum(ranks2) / len(ranks2)\n        \n        numerator = sum((ranks1[i] - mean_rank1) * (ranks2[i] - mean_rank2) for i in range(len(data1)))\n        std_deviation1 = math.sqrt(sum((rank - mean_rank1) ** 2 for rank in ranks1))\n        std_deviation2 = math.sqrt(sum((rank - mean_rank2) ** 2 for rank in ranks2))\n        denominator = std_deviation1 * std_deviation2\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank_data1 = {value: i for i, value in enumerate(sorted(data1))}\n        rank_data2 = {value: i for i, value in enumerate(sorted(data2))}\n        mean_rank_data1 = sum(rank_data1.values()) / len(rank_data1)\n        mean_rank_data2 = sum(rank_data2.values()) / len(rank_data2)\n        \n        numerator = sum((rank_data1[value] - mean_rank_data1) * (rank_data2[value] - mean_rank_data2) for value in data1)\n        \n        deviation_sum_data1 = math.sqrt(sum((rank_data1[value] - mean_rank_data1)**2 for value in data1))\n        deviation_sum_data2 = math.sqrt(sum((rank_data2[value] - mean_rank_data2)**2 for value in data2))\n        \n        denominator = deviation_sum_data1 * deviation_sum_data2\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank_data1 = [sorted(data1).index(i) for i in data1]\n        rank_data2 = [sorted(data2).index(i) for i in data2]\n        \n        mean_rank_data1 = sum(rank_data1) / len(rank_data1)\n        mean_rank_data2 = sum(rank_data2) / len(rank_data2)\n        \n        rank_deviations_product = sum((rank_data1[i] - mean_rank_data1) * (rank_data2[i] - mean_rank_data2) for i in range(len(data1)))\n        \n        rank_squared_deviations_sum1 = sum((r - mean_rank_data1) ** 2 for r in rank_data1)\n        rank_squared_deviations_sum2 = sum((r - mean_rank_data2) ** 2 for r in rank_data2)\n        \n        denominator = math.sqrt(rank_squared_deviations_sum1 * rank_squared_deviations_sum2)\n        \n        return rank_deviations_product / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank_data1 = [sorted(data1).index(i) for i in data1] \n        rank_data2 = [sorted(data2).index(i) for i in data2]\n        mean_rank_data1 = sum(rank_data1) / len(rank_data1)\n        mean_rank_data2 = sum(rank_data2) / len(rank_data2)\n        numerator = sum((rank_data1[i] - mean_rank_data1) * (rank_data2[i] - mean_rank_data2) for i in range(len(data1)))\n        std_dev_rank_data1 = math.sqrt(sum((r - mean_rank_data1) ** 2 for r in rank_data1))\n        std_dev_rank_data2 = math.sqrt(sum((r - mean_rank_data2) ** 2 for r in rank_data2))\n        denominator = std_dev_rank_data1 * std_dev_rank_data2\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank1 = [sorted(data1).index(i) for i in data1]\n        rank2 = [sorted(data2).index(i) for i in data2]\n        \n        n = len(data1)\n        avg_rank1 = sum(rank1) / n\n        avg_rank2 = sum(rank2) / n\n        \n        numerator = sum((rank1[i] - avg_rank1) * (rank2[i] - avg_rank2) for i in range(n))\n        \n        sd_rank1 = math.sqrt(sum((r - avg_rank1) ** 2 for r in rank1))\n        sd_rank2 = math.sqrt(sum((r - avg_rank2) ** 2 for r in rank2))\n        \n        denominator = sd_rank1 * sd_rank2\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        # Rank the data\n        rank_data1 = {val: i for i, val in enumerate(sorted(set(data1)))}\n        rank_data2 = {val: i for i, val in enumerate(sorted(set(data2)))}\n\n        # Calculate the average rank for both datasets\n        avg_rank_data1 = sum(rank_data1[val] for val in data1) / len(data1)\n        avg_rank_data2 = sum(rank_data2[val] for val in data2) / len(data2)\n\n        # Calculate the numerator\n        numerator = sum((rank_data1[data1[i]] - avg_rank_data1) * (rank_data2[data2[i]] - avg_rank_data2) for i in range(len(data1)))\n\n        # Calculate the denominators\n        denominator_data1 = math.sqrt(sum((rank_data1[val] - avg_rank_data1) ** 2 for val in data1))\n        denominator_data2 = math.sqrt(sum((rank_data2[val] - avg_rank_data2) ** 2 for val in data2))\n\n        # Calculate the correlation coefficient\n        correlation_coefficient = numerator / (denominator_data1 * denominator_data2)\n\n        return correlation_coefficient",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        data1 = [rank+1 for rank in sorted(range(len(data1)), key=lambda k: data1[k])]\n        data2 = [rank+1 for rank in sorted(range(len(data2)), key=lambda k: data2[k])]\n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n        numerator = sum([(data1[i] - mean_data1) * (data2[i] - mean_data2) for i in range(len(data1))])\n        std_dev_data1 = math.sqrt(sum([(rank - mean_data1)**2 for rank in data1]))\n        std_dev_data2 = math.sqrt(sum([(rank - mean_data2)**2 for rank in data2]))\n        denominator = std_dev_data1 * std_dev_data2\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        n = len(data1)\n        rank_data1 = {val: i for i, val in enumerate(sorted(data1))}\n        rank_data2 = {val: i for i, val in enumerate(sorted(data2))}\n\n        mean_rank_data1 = sum(rank_data1[val] for val in data1) / n\n        mean_rank_data2 = sum(rank_data2[val] for val in data2) / n\n\n        numerator = sum((rank_data1[data1[i]] - mean_rank_data1) * (rank_data2[data2[i]] - mean_rank_data2) for i in range(n))\n        \n        sum_sq_dev_1 = sum((rank_data1[val] - mean_rank_data1) ** 2 for val in data1)\n        sum_sq_dev_2 = sum((rank_data2[val] - mean_rank_data2) ** 2 for val in data2)\n        denominator = math.sqrt(sum_sq_dev_1 * sum_sq_dev_2)\n\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        n = len(data1)\n        rank_data1 = [sorted(data1).index(x) for x in data1]\n        rank_data2 = [sorted(data2).index(x) for x in data2]\n        \n        sum_rank_data1 = sum(rank_data1)\n        sum_rank_data2 = sum(rank_data2)\n        \n        mean_rank_data1 = sum_rank_data1 / n\n        mean_rank_data2 = sum_rank_data2 / n\n        \n        numerator = sum((x - mean_rank_data1) * (y - mean_rank_data2) for x, y in zip(rank_data1, rank_data2))\n        denominator = math.sqrt(sum((x - mean_rank_data1) ** 2 for x in rank_data1) * sum((y - mean_rank_data2) ** 2 for y in rank_data2))\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    n = len(data1)\n    rank_data1 = [sorted(data1).index(x) for x in data1]\n    rank_data2 = [sorted(data2).index(x) for x in data2]\n\n    mean_rank_data1 = sum(rank_data1) / n\n    mean_rank_data2 = sum(rank_data2) / n\n\n    numerator = sum((rank_data1[i] - mean_rank_data1) * (rank_data2[i] - mean_rank_data2) for i in range(n))\n    denominator = math.sqrt(sum((rank_data1[i] - mean_rank_data1)**2 for i in range(n))) * math.sqrt(sum((rank_data2[i] - mean_rank_data2)**2 for i in range(n))\n\n    return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        n = len(data1)\n        data1_rank = [sorted(data1).index(x) for x in data1]\n        data2_rank = [sorted(data2).index(x) for x in data2]\n        mean_rank1 = sum(data1_rank) / n\n        mean_rank2 = sum(data2_rank) / n\n        numerator = sum((data1_rank[i] - mean_rank1) * (data2_rank[i] - mean_rank2) for i in range(n))\n        denominator = math.sqrt(sum((data1_rank[i] - mean_rank1) ** 2 for i in range(n)) * sum((data2_rank[i] - mean_rank2) ** 2 for i in range(n)))\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        n = len(data1)\n        rank_data1 = [sorted(data1).index(x) for x in data1]\n        rank_data2 = [sorted(data2).index(x) for x in data2]\n        mean_rank_data1 = sum(rank_data1) / n\n        mean_rank_data2 = sum(rank_data2) / n\n        numerator = sum((rank_data1[i] - mean_rank_data1) * (rank_data2[i] - mean_rank_data2) for i in range(n))\n        denominator = math.sqrt(sum((rank_data1[i] - mean_rank_data1) ** 2 for i in range(n)) * sum((rank_data2[i] - mean_rank_data2) ** 2 for i in range(n)))\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n    data = list(zip(data1, data2))\n    data.sort(key=lambda x: x[0])\n    data1_rank = {d[0]: i for i, d in enumerate(data)}\n    data.sort(key=lambda x: x[1])\n    data2_rank = {d[1]: i for i, d in enumerate(data)}\n\n    n = len(data)\n    mean_rank_data1 = sum(data1_rank.values()) / n\n    mean_rank_data2 = sum(data2_rank.values()) / n\n\n    numerator = sum((data1_rank[d1] - mean_rank_data1) * (data2_rank[d2] - mean_rank_data2) for d1, d2 in data)\n    denominator = math.sqrt(sum((data1_rank[d1] - mean_rank_data1) ** 2 for d1, _ in data) * sum((data2_rank[d2] - mean_rank_data2) ** 2 for _, d2 in data))\n\n    return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        mean_rank_data1 = sum((sorted(data1).index(x) for x in data1)) / len(data1)\n        mean_rank_data2 = sum((sorted(data2).index(x) for x in data2)) / len(data2)\n        \n        numerator = sum((sorted(data1).index(x) - mean_rank_data1) * (sorted(data2).index(y) - mean_rank_data2) for x, y in zip(data1, data2))\n        \n        sum_squared_diff_data1 = sum((sorted(data1).index(x) - mean_rank_data1) ** 2 for x in data1)\n        sum_squared_diff_data2 = sum((sorted(data2).index(y) - mean_rank_data2) ** 2 for y in data2)\n        denominator = math.sqrt(sum_squared_diff_data1 * sum_squared_diff_data2)\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank1 = [sorted(data1).index(i) for i in data1]\n        rank2 = [sorted(data2).index(i) for i in data2]\n        mean_rank1 = sum(rank1) / len(rank1)\n        mean_rank2 = sum(rank2) / len(rank2)\n        rank_diff1 = [r - mean_rank1 for r in rank1]\n        rank_diff2 = [r - mean_rank2 for r in rank2]\n        numerator = sum([a * b for a, b in zip(rank_diff1, rank_diff2)])\n        denominator = math.sqrt(sum([d**2 for d in rank_diff1])) * math.sqrt(sum([d**2 for d in rank_diff2]))\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        mean_rank_data1 = sum([sorted(data1).index(x) for x in data1]) / len(data1)\n        mean_rank_data2 = sum([sorted(data2).index(x) for x in data2]) / len(data2)\n\n        numerator = sum((sorted(data1).index(data1[i]) - mean_rank_data1) * (sorted(data2).index(data2[i]) - mean_rank_data2) for i in range(len(data1)))\n        denominator = math.sqrt(sum((sorted(data1).index(x) - mean_rank_data1) ** 2 for x in data1) * sum((sorted(data2).index(y) - mean_rank_data2) ** 2 for y in data2))\n\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        sorted_data1 = sorted(data1)\n        sorted_data2 = sorted(data2)\n        n = len(data1)\n        \n        rank_data1 = [sorted_data1.index(i) for i in data1]\n        rank_data2 = [sorted_data2.index(i) for i in data2]\n        \n        mean_rank_data1 = sum(rank_data1) / n\n        mean_rank_data2 = sum(rank_data2) / n\n        \n        numerator = sum((rank_data1[i] - mean_rank_data1) * (rank_data2[i] - mean_rank_data2) for i in range(n))\n        \n        sum_sqr_diff_rank_data1 = sum((rank_data1[i] - mean_rank_data1)**2 for i in range(n))\n        sum_sqr_diff_rank_data2 = sum((rank_data2[i] - mean_rank_data2)**2 for i in range(n))\n        \n        denominator = math.sqrt(sum_sqr_diff_rank_data1 * sum_sqr_diff_rank_data2)\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank1 = [sorted(data1).index(x) for x in data1]\n        rank2 = [sorted(data2).index(x) for x in data2]\n        mean_rank1 = sum(rank1) / len(data1)\n        mean_rank2 = sum(rank2) / len(data2)\n        \n        numerator = sum((r1 - mean_rank1) * (r2 - mean_rank2) for r1, r2 in zip(rank1, rank2))\n        denominator = math.sqrt(sum((r - mean_rank1) ** 2 for r in rank1) * sum((r - mean_rank2) ** 2 for r in rank2))\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank_data1 = [sorted(data1).index(i) for i in data1]\n        rank_data2 = [sorted(data2).index(i) for i in data2]\n        mean_rank_data1 = sum(rank_data1) / len(rank_data1)\n        mean_rank_data2 = sum(rank_data2) / len(rank_data2)\n        numerator = sum((rank_data1[i] - mean_rank_data1) * (rank_data2[i] - mean_rank_data2) for i in range(len(data1)))\n        denominator = math.sqrt(sum((rank - mean_rank_data1) ** 2 for rank in rank_data1)) * math.sqrt(sum((rank - mean_rank_data2) ** 2 for rank in rank_data2))\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank1 = {value: i for i, value in enumerate(sorted(data1))}\n        rank2 = {value: i for i, value in enumerate(sorted(data2))}\n        n = len(data1)\n        mean_rank1 = sum(rank1[value] for value in data1) / n\n        mean_rank2 = sum(rank2[value] for value in data2) / n\n        numerator = sum((rank1[data1[i]] - mean_rank1) * (rank2[data2[i]] - mean_rank2) for i in range(n))\n        denominator = math.sqrt(sum((rank1[value] - mean_rank1) ** 2 for value in data1) * sum((rank2[value] - mean_rank2) ** 2 for value in data2))\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x) for x in data1]\n        ranked_data2 = [sorted(data2).index(x) for x in data2]\n\n        mean_rank1 = sum(ranked_data1) / len(ranked_data1)\n        mean_rank2 = sum(ranked_data2) / len(ranked_data2)\n\n        numerator = sum((x - mean_rank1) * (y - mean_rank2) for x, y in zip(ranked_data1, ranked_data2))\n        denominator = math.sqrt(sum((x - mean_rank1) ** 2 for x in ranked_data1) * sum((y - mean_rank2) ** 2 for y in ranked_data2))\n\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank1 = [sorted(data1).index(i) for i in data1]\n        rank2 = [sorted(data2).index(i) for i in data2]\n        mean_rank1 = sum(rank1)/len(rank1)\n        mean_rank2 = sum(rank2)/len(rank2)\n        \n        numerator = sum((rank1[i] - mean_rank1) * (rank2[i] - mean_rank2) for i in range(len(data1)))\n        denominator = math.sqrt(sum((rank1[i] - mean_rank1)**2 for i in range(len(data1))) * sum((rank2[i] - mean_rank2)**2 for i in range(len(data2)))\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank_data1 = [sorted(data1).index(i) for i in data1]\n        rank_data2 = [sorted(data2).index(i) for i in data2]\n        \n        mean_rank_data1 = sum(rank_data1) / len(rank_data1)\n        mean_rank_data2 = sum(rank_data2) / len(rank_data2)\n        \n        numerator = sum((rank_data1[i] - mean_rank_data1) * (rank_data2[i] - mean_rank_data2) for i in range(len(data1)))\n        \n        sd_data1 = math.sqrt(sum((r - mean_rank_data1) ** 2 for r in rank_data1))\n        sd_data2 = math.sqrt(sum((r - mean_rank_data2) ** 2 for r in rank_data2))\n        \n        denominator = sd_data1 * sd_data2\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        rank_data1 = [sorted(data1).index(i) for i in data1]\n        rank_data2 = [sorted(data2).index(i) for i in data2]\n        \n        mean_rank_data1 = sum(rank_data1) / len(rank_data1)\n        mean_rank_data2 = sum(rank_data2) / len(rank_data2)\n        \n        numerator = sum((rank_data1[i] - mean_rank_data1) * (rank_data2[i] - mean_rank_data2) for i in range(len(data1)))\n        \n        std_dev_data1 = math.sqrt(sum((r - mean_rank_data1) ** 2 for r in rank_data1))\n        std_dev_data2 = math.sqrt(sum((r - mean_rank_data2) ** 2 for r in rank_data2))\n        \n        denominator = std_dev_data1 * std_dev_data2\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x) for x in data1]\n        ranked_data2 = [sorted(data2).index(x) for x in data2]\n        mean_rank1 = sum(ranked_data1) / len(data1)\n        mean_rank2 = sum(ranked_data2) / len(data2)\n        numerator = sum((x - mean_rank1) * (y - mean_rank2) for x, y in zip(ranked_data1, ranked_data2))\n        denom1 = math.sqrt(sum((x - mean_rank1) ** 2 for x in ranked_data1))\n        denom2 = math.sqrt(sum((y - mean_rank2) ** 2 for y in ranked_data2))\n        return numerator / (denom1 * denom2)",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        sorted_data1 = sorted(range(len(data1)), key=lambda k: data1[k])\n        sorted_data2 = sorted(range(len(data2)), key=lambda k: data2[k])\n        N = len(data1)\n        rank_data1 = [0] * N\n        rank_data2 = [0] * N\n        for i in range(N):\n            rank_data1[sorted_data1[i]] = i\n            rank_data2[sorted_data2[i]] = i\n        mean_rank1 = sum(rank_data1) / N\n        mean_rank2 = sum(rank_data2) / N\n        numer = sum([(rank_data1[i] - mean_rank1) * (rank_data2[i] - mean_rank2) for i in range(N)])\n        \n        std_rank1 = math.sqrt(sum([(r - mean_rank1) ** 2 for r in rank_data1]))\n        std_rank2 = math.sqrt(sum([(r - mean_rank2) ** 2 for r in rank_data2]))\n        \n        denom = std_rank1 * std_rank2\n        \n        return numer / denom",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        data1 = [rank+1 for rank in sorted(range(len(data1)), key=lambda k: data1[k])]\n        data2 = [rank+1 for rank in sorted(range(len(data2)), key=lambda k: data2[k])]\n        n = len(data1)\n        mean_data1 = sum(data1) / n\n        mean_data2 = sum(data2) / n\n        numerator = sum((data1[i] - mean_data1) * (data2[i] - mean_data2) for i in range(n))\n        std_dev_data1 = math.sqrt(sum((rank - mean_data1) ** 2 for rank in data1))\n        std_dev_data2 = math.sqrt(sum((rank - mean_data2) ** 2 for rank in data2))\n        denominator = std_dev_data1 * std_dev_data2\n        return numerator / denominator",
                false
            ]
        ],
        "level 3": [
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x) + 1 for x in data1]\n        ranked_data2 = [sorted(data2).index(x) + 1 for x in data2]\n        \n        n = len(data1)\n        mean_rank1 = sum(ranked_data1) / n\n        mean_rank2 = sum(ranked_data2) / n\n        \n        covariance = sum((ranked_data1[i] - mean_rank1) * (ranked_data2[i] - mean_rank2) for i in range(n))\n        \n        sum_sq_diff1 = sum((rank - mean_rank1) ** 2 for rank in ranked_data1)\n        sum_sq_diff2 = sum((rank - mean_rank2) ** 2 for rank in ranked_data2)\n        \n        denominator = math.sqrt(sum_sq_diff1 * sum_sq_diff2)\n        \n        if denominator == 0:\n            return 0\n        \n        return covariance / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x)+1 for x in data1]\n        ranked_data2 = [sorted(data2).index(x)+1 for x in data2]\n        \n        n = len(data1)\n        mean_rank1 = sum(ranked_data1) / n\n        mean_rank2 = sum(ranked_data2) / n\n        \n        numerator = sum((ranked_data1[i] - mean_rank1) * (ranked_data2[i] - mean_rank2) for i in range(n))\n        \n        rank_diff1 = [(ranked_data1[i] - mean_rank1)**2 for i in range(n)]\n        rank_diff2 = [(ranked_data2[i] - mean_rank2)**2 for i in range(n)]\n        \n        denominator = math.sqrt(sum(rank_diff1) * sum(rank_diff2))\n        \n        if denominator == 0:\n            return 0.0\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x) + 1 for x in data1]\n        ranked_data2 = [sorted(data2).index(x) + 1 for x in data2]\n\n        n = len(data1)\n        mean_rank_data1 = sum(ranked_data1) / n\n        mean_rank_data2 = sum(ranked_data2) / n\n\n        numerator = sum((ranked_data1[i] - mean_rank_data1) * (ranked_data2[i] - mean_rank_data2) for i in range(n))\n\n        sum_sq_diff_data1 = sum((ranked_data1[i] - mean_rank_data1) ** 2 for i in range(n))\n        sum_sq_diff_data2 = sum((ranked_data2[i] - mean_rank_data2) ** 2 for i in range(n)\n        denominator = math.sqrt(sum_sq_diff_data1) * math.sqrt(sum_sq_diff_data2)\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = {v: i+1 for i, v in enumerate(sorted(data1))}\n        ranked_data2 = {v: i+1 for i, v in enumerate(sorted(data2))}\n        \n        n = len(data1)\n        mean_rank_data1 = sum(ranked_data1.values()) / n\n        mean_rank_data2 = sum(ranked_data2.values()) / n\n        \n        numerator = sum((ranked_data1[val] - mean_rank_data1) * (ranked_data2[val] - mean_rank_data2) for val in data1)\n        \n        sum_rank_diff_sq_data1 = sum((ranked_data1[val] - mean_rank_data1) ** 2 for val in data1)\n        sum_rank_diff_sq_data2 = sum((ranked_data2[val] - mean_rank_data2) ** 2 for val in data2)\n        \n        denominator = math.sqrt(sum_rank_diff_sq_data1 * sum_rank_diff_sq_data2)\n        \n        if denominator == 0:\n            return 0.0\n        \n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = {value: i + 1 for i, value in enumerate(sorted(data1))}\n        ranked_data2 = {value: i + 1 for i, value in enumerate(sorted(data2))}\n        mean_rank1 = sum(ranked_data1.values()) / len(data1)\n        mean_rank2 = sum(ranked_data2.values()) / len(data2)\n        numerator = sum((ranked_data1[value] - mean_rank1) * (ranked_data2[value] - mean_rank2) for value in data1)\n        rank_diff1 = [(ranked_data1[value] - mean_rank1) ** 2 for value in data1]\n        rank_diff2 = [(ranked_data2[value] - mean_rank2) ** 2 for value in data2]\n        denominator = math.sqrt(sum(rank_diff1) * sum(rank_diff2))\n        if denominator == 0:\n            return 0.0\n        return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x) + 1 for x in data1]\n        ranked_data2 = [sorted(data2).index(x) + 1 for x in data2]\n\n        n = len(data1)\n        avg_rank_data1 = sum(ranked_data1) / n\n        avg_rank_data2 = sum(ranked_data2) / n\n\n        numerator = sum((ranked_data1[i] - avg_rank_data1) * (ranked_data2[i] - avg_rank_data2) for i in range(n))\n\n        std_dev_data1 = math.sqrt(sum((r - avg_rank_data1) ** 2 for r in ranked_data1))\n        std_dev_data2 = math.sqrt(sum((r - avg_rank_data2) ** 2 for r in ranked_data2))\n\n        denominator = std_dev_data1 * std_dev_data2\n\n        if denominator == 0:\n            return 0.0\n        else:\n            return numerator / denominator",
                true
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = {data1[i]: i+1 for i in range(len(data1))}\n        ranked_data2 = {data2[i]: i+1 for i in range(len(data2)}\n        n = len(data1)\n        avg_rank1 = sum(ranked_data1.values()) / n\n        avg_rank2 = sum(ranked_data2.values()) / n\n        numerator = sum((ranked_data1[val] - avg_rank1) * (ranked_data2[val] - avg_rank2) for val in data1)\n        denom1 = math.sqrt(sum((ranked_data1[val] - avg_rank1)**2 for val in data1))\n        denom2 = math.sqrt(sum((ranked_data2[val] - avg_rank2)**2 for val in data2))\n        denominator = denom1 * denom2\n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = {v: i + 1 for i, v in enumerate(sorted(data1))}\n        ranked_data2 = {v: i + 1 for i, v in enumerate(sorted(data2))}\n        n = len(data1)\n        avg_rank1 = sum(ranked_data1.values()) / n\n        avg_rank2 = sum(ranked_data2.values()) / n\n        numerator = sum((ranked_data1[val] - avg_rank1) * (ranked_data2[val] - avg_rank2) for val in data1)\n        std_dev1 = math.sqrt(sum((ranked_data1[val] - avg_rank1) ** 2 for val in data1))\n        std_dev2 = math.sqrt(sum((ranked_data2[val] - avg_rank2) ** 2 for val in data2))\n        denominator = std_dev1 * std_dev2\n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = {v: i + 1 for i, v in enumerate(sorted(data1))}\n        ranked_data2 = {v: i + 1 for i, v in enumerate(sorted(data2))}\n        n = len(data1)\n        avg_rank_data1 = sum(ranked_data1[v] for v in data1) / n\n        avg_rank_data2 = sum(ranked_data2[v] for v in data2) / n\n        numerator = sum((ranked_data1[data1[i]] - avg_rank_data1) * (ranked_data2[data2[i]] - avg_rank_data2) for i in range(n))\n        std_dev1 = math.sqrt(sum((ranked_data1[v] - avg_rank_data1) ** 2 for v in data1))\n        std_dev2 = math.sqrt(sum((ranked_data2[v] - avg_rank_data2) ** 2 for v in data2))\n        denominator = std_dev1 * std_dev2\n        return numerator / denominator if denominator != 0 else 0",
                true
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = {i + 1: rank for i, rank in enumerate(sorted(data1))}\n        ranked_data2 = {i + 1: rank for i, rank in enumerate(sorted(data2))}\n\n        avg_rank_data1 = sum(ranked_data1.values()) / len(data1)\n        avg_rank_data2 = sum(ranked_data2.values()) / len(data2)\n\n        numerator = sum((ranked_data1[i] - avg_rank_data1) * (ranked_data2[i] - avg_rank_data2) for i in range(1, len(data1) + 1))\n\n        std_dev_data1 = math.sqrt(sum((rank - avg_rank_data1) ** 2 for rank in ranked_data1.values()))\n        std_dev_data2 = math.sqrt(sum((rank - avg_rank_data2) ** 2 for rank in ranked_data2.values()))\n\n        denominator = std_dev_data1 * std_dev_data2\n\n        if denominator == 0:\n            return 0.0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = {val: i+1 for i, val in enumerate(sorted(data1))}\n        ranked_data2 = {val: i+1 for i, val in enumerate(sorted(data2))}\n\n        n = len(data1)\n        mean_rank1 = sum(ranked_data1[val] for val in data1) / n\n        mean_rank2 = sum(ranked_data2[val] for val in data2) / n\n\n        numerator = sum((ranked_data1[data1[i]] - mean_rank1) * (ranked_data2[data2[i]] - mean_rank2) for i in range(n))\n\n        rank_deviation1 = math.sqrt(sum((ranked_data1[val] - mean_rank1) ** 2 for val in data1))\n        rank_deviation2 = math.sqrt(sum((ranked_data2[val] - mean_rank2) ** 2 for val in data2))\n\n        denominator = rank_deviation1 * rank_deviation2\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                true
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = sorted(enumerate(data1), key=lambda x: x[1])\n        ranked_data2 = sorted(enumerate(data2), key=lambda x: x[1])\n        n = len(data1)\n        mean_rank1 = sum(rank + 1 for rank, _ in ranked_data1) / n\n        mean_rank2 = sum(rank + 1 for rank, _ in ranked_data2) / n\n        \n        numerator = sum((rank1 - mean_rank1) * (rank2 - mean_rank2) for (rank1, _), (rank2, _) in zip(ranked_data1, ranked_data2))\n        \n        rank_deviation1 = math.sqrt(sum((rank - mean_rank1) ** 2 for rank, _ in ranked_data1))\n        rank_deviation2 = math.sqrt(sum((rank - mean_rank2) ** 2 for rank, _ in ranked_data2))\n        \n        denominator = rank_deviation1 * rank_deviation2\n        \n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = sorted(data1)\n        ranked_data2 = sorted(data2)\n        n = len(data1)\n        rank_sum1 = sum([i+1 for i in range(n)])\n        rank_sum2 = sum([i+1 for i in range(n)])\n        mean_rank1 = rank_sum1 / n\n        mean_rank2 = rank_sum2 / n\n\n        deviations1 = [ranked_data1[i] - mean_rank1 for i in range(n)]\n        deviations2 = [ranked_data2[i] - mean_rank2 for i in range(n)]\n\n        numerator = sum([deviations1[i] * deviations2[i] for i in range(n)])\n\n        rank_deviation_sq1 = sum([deviations1[i] ** 2 for i in range(n)])\n        rank_deviation_sq2 = sum([deviations2[i] ** 2 for i in range(n])\n        \n        denom = math.sqrt(rank_deviation_sq1 * rank_deviation_sq2)\n        \n        if denom != 0:\n            correlation_coefficient = numerator / denom\n        else:\n            correlation_coefficient = 0\n            \n        return correlation_coefficient",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = sorted(data1)\n        ranked_data2 = sorted(data2)\n        n = len(data1)\n        ranked_data1 = {value: i + 1 for i, value in enumerate(ranked_data1)}\n        ranked_data2 = {value: i + 1 for i, value in enumerate(ranked_data2)}\n        mean_rank1 = sum(ranked_data1.values()) / n\n        mean_rank2 = sum(ranked_data2.values()) / n\n        numerator = sum((ranked_data1[data1[i]] - mean_rank1) * (ranked_data2[data2[i]] - mean_rank2) for i in range(n))\n        \n        rank_deviation1 = math.sqrt(sum((ranked_data1[data] - mean_rank1) ** 2 for data in data1))\n        rank_deviation2 = math.sqrt(sum((ranked_data2[data] - mean_rank2) ** 2 for data in data2))\n        denominator = rank_deviation1 * rank_deviation2\n        \n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = sorted(data1)\n        ranked_data2 = sorted(data2)\n        n = len(data1)\n        ranked_data1 = {value: i+1 for i, value in enumerate(ranked_data1)}\n        ranked_data2 = {value: i+1 for i, value in enumerate(ranked_data2)}\n        mean_rank1 = sum(ranked_data1.values()) / n\n        mean_rank2 = sum(ranked_data2.values()) / n\n        \n        numerator = sum((ranked_data1[d] - mean_rank1) * (ranked_data2[d] - mean_rank2) for d in data1)\n        \n        rank_deviation1 = math.sqrt(sum((ranked_data1[d] - mean_rank1)**2 for d in data1))\n        rank_deviation2 = math.sqrt(sum((ranked_data2[d] - mean_rank2)**2 for d in data2))\n        \n        denominator = rank_deviation1 * rank_deviation2\n        \n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(i) + 1 for i in data1]\n        ranked_data2 = [sorted(data2).index(i) + 1 for i in data2]\n        \n        n = len(data1)\n        \n        avg_rank1 = sum(ranked_data1) / n\n        avg_rank2 = sum(ranked_data2) / n\n        \n        numerator = sum((ranked_data1[i] - avg_rank1) * (ranked_data2[i] - avg_rank2) for i in range(n))\n        \n        sum_sq_rank1 = sum((rank - avg_rank1) ** 2 for rank in ranked_data1)\n        sum_sq_rank2 = sum((rank - avg_rank2) ** 2 for rank in ranked_data2)\n        \n        denominator = math.sqrt(sum_sq_rank1) * math.sqrt(sum_sq_rank2)\n        \n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                true
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = sorted(data1)\n        ranked_data2 = sorted(data2)\n        n = len(data1)\n        avg_rank_data1 = sum(ranked_data1) / n\n        avg_rank_data2 = sum(ranked_data2) / n\n        numerator = sum((ranked_data1[i] - avg_rank_data1) * (ranked_data2[i] - avg_rank_data2) for i in range(n))\n        denominator = math.sqrt(sum((ranked_data1[i] - avg_rank_data1) ** 2 for i in range(n))) * math.sqrt(sum((ranked_data2[i] - avg_rank_data2) ** 2 for i in range(n))\n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = sorted(data1)\n        ranked_data2 = sorted(data2)\n        \n        rank_map1 = {v: i+1 for i, v in enumerate(ranked_data1)}\n        rank_map2 = {v: i+1 for i, v in enumerate(ranked_data2)}\n        \n        n = len(data1)\n        \n        sum_rank1 = sum(rank_map1[v] for v in data1)\n        sum_rank2 = sum(rank_map2[v] for v in data2)\n        \n        avg_rank1 = sum_rank1 / n\n        avg_rank2 = sum_rank2 / n\n\n        numerator = sum((rank_map1[data1[i]] - avg_rank1) * (rank_map2[data2[i]] - avg_rank2) for i in range(n))\n\n        sum_sq_dev1 = sum((rank_map1[v] - avg_rank1) ** 2 for v in ranked_data1)\n        sum_sq_dev2 = sum((rank_map2[v] - avg_rank2) ** 2 for v in ranked_data2)\n        \n        denominator = math.sqrt(sum_sq_dev1) * math.sqrt(sum_sq_dev2) if sum_sq_dev1 != 0 and sum_sq_dev2 != 0 else 0\n        \n        return numerator / denominator if denominator != 0 else 0",
                true
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = {v: i+1 for i, v in enumerate(sorted(data1))}\n        ranked_data2 = {v: i+1 for i, v in enumerate(sorted(data2))}\n        n = len(data1)\n        avg_rank1 = sum(ranked_data1[v] for v in data1) / n\n        avg_rank2 = sum(ranked_data2[v] for v in data2) / n\n        num = sum((ranked_data1[data1[i]] - avg_rank1) * (ranked_data2[data2[i]] - avg_rank2) for i in range(n))\n        den1 = math.sqrt(sum((ranked_data1[v] - avg_rank1)**2 for v in data1))\n        den2 = math.sqrt(sum((ranked_data2[v] - avg_rank2)**2 for v in data2))\n        den = den1 * den2\n        if den == 0:\n            return 0.0\n        return num / den",
                true
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = {val: idx + 1 for idx, val in enumerate(sorted(data1))}\n        ranked_data2 = {val: idx + 1 for idx, val in enumerate(sorted(data2))}\n        n = len(data1)\n        avg_rank1 = sum(ranked_data1[val] for val in data1) / n\n        avg_rank2 = sum(ranked_data2[val] for val in data2) / n\n        \n        numerator = sum((ranked_data1[data1[i]] - avg_rank1) * (ranked_data2[data2[i]] - avg_rank2) for i in range(n))\n        denominator = math.sqrt(sum((ranked_data1[val] - avg_rank1)**2 for val in data1) * sum((ranked_data2[val] - avg_rank2)**2 for val in data2))\n        \n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = sorted(data1)\n        ranked_data2 = sorted(data2)\n        n = len(data1)\n        ranked_data1 = [ranked_data1.index(d) + 1 for d in data1]\n        ranked_data2 = [ranked_data2.index(d) + 1 for d in data2]\n\n        mean_rank = (sum(ranked_data1) + sum(ranked_data2)) / (2 * n)\n        numerator = sum((ranked_data1[i] - mean_rank) * (ranked_data2[i] - mean_rank) for i in range(n))\n        \n        rank_diffs1 = [ranked_data1[i] - mean_rank for i in range(n)]\n        rank_diffs2 = [ranked_data2[i] - mean_rank for i in range(n)]\n        \n        denominator = math.sqrt(sum(d**2 for d in rank_diffs1) * sum(d**2 for d in rank_diffs2))\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = sorted(data1)\n        ranked_data2 = sorted(data2)\n        n = len(data1)\n        mean_rank = (sum(range(1, n + 1)) / n)\n        numerator = sum((ranked_data1.index(data1[i]) - mean_rank) * (ranked_data2.index(data2[i]) - mean_rank) for i in range(n))\n        denominator = math.sqrt(sum((ranked_data1.index(data1[i]) - mean_rank)**2 for i in range(n)) * sum((ranked_data2.index(data2[i]) - mean_rank)**2 for i in range(n)))\n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x) + 1 for x in data1]\n        ranked_data2 = [sorted(data2).index(x) + 1 for x in data2]\n        n = len(data1)\n        mean_rank = (sum(ranked_data1) + sum(ranked_data2)) / (2*n)\n        \n        numerator = sum((ranked_data1[i] - mean_rank) * (ranked_data2[i] - mean_rank) for i in range(n))\n        \n        rank_diff1 = sum((ranked_data1[i] - mean_rank)**2 for i in range(n))\n        rank_diff2 = sum((ranked_data2[i] - mean_rank)**2 for i in range(n))\n        denominator = math.sqrt(rank_diff1 * rank_diff2)\n        \n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x)+1 for x in data1]\n        ranked_data2 = [sorted(data2).index(x)+1 for x in data2]\n        \n        n = len(data1)\n        mean_rank = (sum(ranked_data1) + sum(ranked_data2)) / (2 * n)\n        \n        numerator = sum((ranked_data1[i] - mean_rank) * (ranked_data2[i] - mean_rank) for i in range(n))\n        \n        rank_diff1 = sum((ranked_data1[i] - mean_rank)**2 for i in range(n))\n        rank_diff2 = sum((ranked_data2[i] - mean_rank)**2 for i in range(n))\n        denominator = math.sqrt(rank_diff1 * rank_diff2)\n        \n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = sorted(data1)\n        ranked_data2 = sorted(data2)\n        n = len(data1)\n        mean_rank = sum(range(1, n+1)) / n\n        num = sum((ranked_data1[i] - mean_rank) * (ranked_data2[i] - mean_rank) for i in range(n))\n        den = math.sqrt(sum((ranked_data1[i] - mean_rank)**2 for i in range(n)) * sum((ranked_data2[i] - mean_rank)**2 for i in range(n)))\n        return num / den if den != 0 else 0",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = sorted(data1)\n        ranked_data2 = sorted(data2)\n        n = len(data1)\n        \n        rank_dict1 = {val: i+1 for i, val in enumerate(sorted(data1))}\n        rank_dict2 = {val: i+1 for i, val in enumerate(sorted(data2))}\n        \n        mean_rank1 = sum(rank_dict1[val] for val in data1) / n\n        mean_rank2 = sum(rank_dict2[val] for val in data2) / n\n        \n        numerator = sum((rank_dict1[data1[i]] - mean_rank1) * (rank_dict2[data2[i]] - mean_rank2) for i in range(n))\n        \n        sum_sq_diff1 = sum((rank_dict1[val] - mean_rank1)**2 for val in data1)\n        sum_sq_diff2 = sum((rank_dict2[val] - mean_rank2)**2 for val in data2)\n        \n        denominator = math.sqrt(sum_sq_diff1) * math.sqrt(sum_sq_diff2)\n        \n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                true
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(i) + 1 for i in data1]\n        ranked_data2 = [sorted(data2).index(i) + 1 for i in data2]\n        n = len(data1)\n        mean_rank_data1 = sum(ranked_data1) / n\n        mean_rank_data2 = sum(ranked_data2) / n\n        numerator = sum((ranked_data1[i] - mean_rank_data1) * (ranked_data2[i] - mean_rank_data2) for i in range(n))\n        denominator = math.sqrt(sum((ranked_data1[i] - mean_rank_data1) ** 2 for i in range(n)) * sum((ranked_data2[i] - mean_rank_data2) ** 2 for i in range(n)))\n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x) + 1 for x in data1]\n        ranked_data2 = [sorted(data2).index(x) + 1 for x in data2]\n\n        n = len(data1)\n\n        mean_rank_data1 = sum(ranked_data1) / n\n        mean_rank_data2 = sum(ranked_data2) / n\n\n        numerator = sum((ranked_data1[i] - mean_rank_data1) * (ranked_data2[i] - mean_rank_data2) for i in range(n))\n\n        sum_rank1_sq = sum((ranked_data1[i] - mean_rank_data1) ** 2 for i in range(n))\n        sum_rank2_sq = sum((ranked_data2[i] - mean_rank_data2) ** 2 for i in range(n)\n\n        denominator = math.sqrt(sum_rank1_sq * sum_rank2_sq)\n\n        if denominator == 0:\n            return 0.0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x) + 1 for x in data1]\n        ranked_data2 = [sorted(data2).index(x) + 1 for x in data2]\n\n        n = len(data1)\n        mean_rank1 = sum(ranked_data1) / n\n        mean_rank2 = sum(ranked_data2) / n\n\n        numerator = sum((ranked_data1[i] - mean_rank1) * (ranked_data2[i] - mean_rank2) for i in range(n))\n\n        sum_sqr_rank1 = sum((ranked_data1[i] - mean_rank1) ** 2 for i in range(n))\n        sum_sqr_rank2 = sum((ranked_data2[i] - mean_rank2) ** 2 for i in range(n)\n        denominator = math.sqrt(sum_sqr_rank1 * sum_sqr_rank2)\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def correlation_coefficient_rank(data1, data2):\n        ranked_data1 = [sorted(data1).index(x) + 1 for x in data1]\n        ranked_data2 = [sorted(data2).index(x) + 1 for x in data2]\n        n = len(ranked_data1)\n        mean_rank1 = sum(ranked_data1) / n\n        mean_rank2 = sum(ranked_data2) / n\n        numerator = sum((r1 - mean_rank1) * (r2 - mean_rank2) for r1, r2 in zip(ranked_data1, ranked_data2))\n        denominator = math.sqrt(sum((r1 - mean_rank1) ** 2 for r1 in ranked_data1) * sum((r2 - mean_rank2) ** 2 for r2 in ranked_data2))\n        return numerator / denominator if denominator != 0 else 0",
                false
            ]
        ]
    },
    "2": {
        "level 1": [
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], tuple):\n            data = [data]\n        recalls = []\n        for d in data:\n            mrr = MetricsCalculator2.mrr(data)\n            if mrr == 0:\n                recalls.append(0)\n            else:\n                recalls.append(1 / (1 + (d[0].index(1)) * discount_rate))\n        if len(recalls) == 1:\n            return recalls[0]\n        return sum(recalls) / len(recalls), recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        mrr_list = []\n        recall_values = []\n\n        for item in data:\n            rank = item[0].index(1) if 1 in item[0] else len(item[0]) + 1\n            if rank <= len(item[0]):\n                discount = 1 / (1 + (rank - 1) * discount_rate)\n                mrr_list.append(discount)\n            else:\n                mrr_list.append(0)\n            recall = sum(item[0][:item[1]]) / item[1]\n            recall_values.append(recall)\n\n        if isinstance(data[0], tuple):\n            return np.mean(mrr_list), recall_values\n        else:\n            return np.mean(mrr_list), recall_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data[0], tuple):\n            precision = 0\n            for result, num in data:\n                if 1 in result:\n                    rank = result.index(1) + 1\n                    precision = 1 / (rank + (rank - 1) * discount_rate)\n                    recalls.append(precision)\n            return sum(recalls) / len(recalls), recalls\n        else:\n            avg_recalls = []\n            for sublist in data:\n                sublist_recalls = []\n                for result, num in sublist:\n                    if 1 in result:\n                        rank = result.index(1) + 1\n                        precision = 1 / (rank + (rank - 1) * discount_rate)\n                        sublist_recalls.append(precision)\n                avg_recalls.append(sum(sublist_recalls) / len(sublist_recalls))\n            return sum(avg_recalls) / len(avg_recalls), avg_recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    def calculate_recall(result_list, ground_truth_num):\n        relevant_indexes = [i for i, value in enumerate(result_list) if value == 1]\n        if len(relevant_indexes) == 0:\n            return 0.0\n        discounted_position = 1 / (1 + discount_rate * relevant_indexes[0])\n        return discounted_position / ground_truth_num\n\n    if isinstance(data, tuple):\n        return calculate_recall(data[0], data[1]), [calculate_recall(data[0], data[1])]\n    elif isinstance(data, list):\n        recall_values = []\n        total_recall = 0.0\n        for entry in data:\n            recall_value = calculate_recall(entry[0], entry[1])\n            total_recall += recall_value\n            recall_values.append(recall_value)\n        return total_recall / len(data), recall_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data[0], tuple):  # Single tuple\n            actual, ground_truth = data\n            if actual.index(1) == -1:\n                recall = 0\n            else:\n                rank = actual.index(1) + 1\n                recall = 1 / rank\n            return recall, recalls\n        else:  # List of tuples\n            for item in data:\n                actual, ground_truth = item\n                if actual.index(1) == -1:\n                    recall = 0\n                else:\n                    rank = actual.index(1) + 1\n                    recall = 1 / rank\n                recalls.append(recall)\n            return sum(recalls) / len(recalls), recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        discounted_recalls = []\n        \n        if isinstance(data, tuple):\n            actual_results, ground_truth = data\n            rank = actual_results.index(1) + 1\n            recall = 1 / rank\n            discounted_recall = recall / (1 + (rank - 1) * discount_rate)\n            return recall, [discounted_recall]\n        \n        elif isinstance(data, list):\n            for actual_results, ground_truth in data:\n                rank = actual_results.index(1) + 1\n                recall = 1 / rank\n                discounted_recall = recall / (1 + (rank - 1) * discount_rate)\n                recalls.append(recall)\n                discounted_recalls.append(discounted_recall)\n                \n            average_recall = sum(recalls) / len(recalls)\n            return average_recall, discounted_recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recall_values = []\n        if isinstance(data, tuple):\n            recall = 0\n            for i, item in enumerate(data[0]):\n                if item == 1:\n                    recall = 1 / (i + 1)\n                    break\n            return recall, [recall]\n        \n        elif isinstance(data, list):\n            total_recall = 0\n            recall_list = []\n            for entry in data:\n                recall = 0\n                for i, item in enumerate(entry[0]):\n                    if item == 1:\n                        recall = 1 / (i + 1)\n                        break\n                total_recall += recall\n                recall_list.append(recall)\n            return total_recall / len(data), recall_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recall_values = []\n        total_recalls = []\n        if isinstance(data, tuple):\n            data = [data]\n        for item in data:\n            actual_results = item[0]\n            ground_truth_num = item[1]\n            mrr = 0\n            found = False\n            for i, result in enumerate(actual_results):\n                if result == 1 and not found:\n                    mrr = 1 / (i + 1)\n                    found = True\n            discounted_mrr = mrr / (discount_rate ** (ground_truth_num - 1))\n            recall_values.append(discounted_mrr)\n        \n        if len(recall_values) == 1:\n            total_recalls = recall_values[0]\n        else:\n            total_recalls = sum(recall_values) / len(recall_values)\n        \n        return total_recalls, recall_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    recall_list = []\n    if isinstance(data, tuple):\n        recall = 0\n        for idx, (result, total_ground) in enumerate(data):\n            for i, val in enumerate(result):\n                if val == 1:\n                    recall += 1 / (i + 1) * discount_rate\n                    break\n            recall_list.append(recall / total_ground)\n    elif isinstance(data, list):\n        for tup in data:\n            recall = 0\n            for idx, (result, total_ground) in enumerate(tup):\n                for i, val in enumerate(result):\n                    if val == 1:\n                        recall += 1 / (i + 1) * discount_rate\n                        break\n                recall_list.append(recall / total_ground)\n    average_recall = sum(recall_list) / len(recall_list)\n    return average_recall, recall_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data, tuple):\n            data = [data]\n        for tup in data:\n            actual_result = tup[0]\n            ground_truth_num = tup[1]\n            rr = 0\n            for i in range(len(actual_result)):\n                if actual_result[i] == 1:\n                    rr = 1 / (i + 1)\n                    break\n            discounted_rr = rr / discount_rate\n            recalls.append(discounted_rr)\n        average_recall = sum(recalls) / len(recalls)\n        return average_recall, recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data[0], tuple):  # data is a single tuple\n            precision = 0\n            for idx, val in enumerate(data[0]):\n                if val == 1:\n                    precision += 1 / (idx + 1)\n            recalls.append(precision / data[1])\n        else:  # data is a list of tuples\n            for item in data:\n                precision = 0\n                for idx, val in enumerate(item[0]):\n                    if val == 1:\n                        precision += 1 / (idx + 1)\n                recalls.append(precision / item[1])\n        return np.average(recalls), recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    recalls = []\n    if isinstance(data[0], tuple):  # Single tuple\n        num_correct = sum(data[0][0])\n        if num_correct == 0:\n            recalls.append(0)\n        else:\n            index = data[0][0].index(1)\n            recall = 1 / (1 + index * discount_rate)\n            recalls.append(recall)\n    else:  # List of tuples\n        for entry in data:\n            num_correct = sum(entry[0])\n            if num_correct == 0:\n                recalls.append(0)\n            else:\n                index = entry[0].index(1)\n                recall = 1 / (1 + index * discount_rate)\n                recalls.append(recall)\n    avg_recall = sum(recalls) / len(recalls)\n    return avg_recall, recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data[0], tuple):\n            return MetricsCalculator2.mrr(data)\n        else:\n            for d in data:\n                recalls.append(MetricsCalculator2.mrr(d))\n            return np.mean(recalls), recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data[0], tuple):\n            data = [data]\n        for entry in data:\n            mrr = MetricsCalculator2.mrr(entry)\n            discounted_mrr = mrr / (1 + discount_rate * mrr)\n            recalls.append(discounted_mrr)\n        if len(recalls) == 1:\n            return recalls[0], recalls\n        return sum(recalls) / len(recalls), recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data[0], tuple):\n            data = [data]\n        for d in data:\n            idx = 0\n            for i, (actual, ground_truth_num) in enumerate(d):\n                if actual == 1:\n                    idx = i + 1\n                    break\n            recall = 1 / (idx + (idx != 0) * (discount_rate - 1))\n            recalls.append(recall)\n        if len(data) == 1:\n            return recalls[0], recalls\n        return np.mean(recalls), recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data[0], list):\n            for d in data:\n                ground_truth_num = d[1]\n                actual_results = d[0]\n                rank = 1\n                for i, result in enumerate(actual_results):\n                    if result == 1:\n                        recalls.append(1 / (rank * discount_rate))\n                        break\n                    rank += 1\n        else:\n            ground_truth_num = data[1]\n            actual_results = data[0]\n            rank = 1\n            for i, result in enumerate(actual_results):\n                if result == 1:\n                    recalls.append(1 / (rank * discount_rate))\n                    break\n                rank += 1\n        mean_recall = np.mean(recalls)\n        return mean_recall, recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        def reciprocal_rank(rank_list):\n            for i, rank in enumerate(rank_list, 1):\n                if rank == 1:\n                    return 1/i\n            return 0\n\n        if isinstance(data, list):\n            mrr_list = []\n            for d in data:\n                mrr_list.append(reciprocal_rank(d) * discount_rate)\n            return np.mean(mrr_list), mrr_list\n        else:\n            return reciprocal_rank(data) * discount_rate, [reciprocal_rank(data)]",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        def mrr_single_list(data, discount_rate):\n            rank = 1\n            rr = 0\n            for answer in data:\n                if answer == 1:\n                    rr = 1 / (rank ** discount_rate)\n                    break\n                rank += 1\n            return rr\n\n        if isinstance(data, tuple):\n            return mrr_single_list(data[0], discount_rate), [mrr_single_list(data[0], discount_rate)]\n        else:\n            recalls = []\n            for d in data:\n                recalls.append(mrr_single_list(d[0], discount_rate))\n            return sum(recalls) / len(data), recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        def calculate_mrr_single_tuple(single_tuple, discount_rate):\n            actual_result, ground_truth_num = single_tuple\n            discounted_mrr_value = 0\n            for index, result in enumerate(actual_result):\n                if result == 1:\n                    discounted_mrr_value = 1 / (index + 1)\n                    break\n            return discounted_mrr_value\n\n        if isinstance(data, tuple):\n            return calculate_mrr_single_tuple(data, discount_rate), [calculate_mrr_single_tuple(data, discount_rate)]\n        \n        if isinstance(data, list):\n            total_recall = 0\n            recall_list = []\n            for single_tuple in data:\n                single_recall = calculate_mrr_single_tuple(single_tuple, discount_rate)\n                total_recall += single_recall\n                recall_list.append(single_recall)\n            return total_recall / len(data), recall_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data[0], tuple):\n            data = [data]\n        for d in data:\n            num_correct = sum(d[0])\n            rank = d[0].index(1) + 1\n            recall = 1 / rank\n            discounted_recall = recall / (1 + (rank - 1) * discount_rate)\n            recalls.append(discounted_recall)\n        return sum(recalls) / len(recalls), recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    recalls = []\n    if isinstance(data, tuple): \n        actual_result, ground_truth_num = data\n        rank = actual_result.index(1) + 1\n        recalls.append(1 / (rank ** discount_rate))\n        return (1 / (rank ** discount_rate), recalls)\n    \n    elif isinstance(data, list): \n        total_recall = 0\n        precisions = []\n        for tup in data:\n            actual_result, ground_truth_num = tup\n            rank = actual_result.index(1) + 1\n            recall = 1 / (rank ** discount_rate)\n            total_recall += recall\n            recalls.append(recall)\n        return (total_recall / len(data), recalls)",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data, tuple):\n            data = [data]\n        for d in data:\n            n = len(d[0])\n            mrr = 0\n            found = False\n            for i in range(n):\n                if d[0][i] == 1 and not found:\n                    mrr = 1 / (i + 1)\n                    found = True\n            recalls.append(mrr)\n        if isinstance(data, tuple):\n            return recalls[0], recalls\n        else:\n            return np.mean(recalls), recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data, tuple):\n            data = [data]\n        for item in data:\n            actual_results, ground_truth_num = item\n            reciprocal_ranks = [1 / (rank + 1) for rank, result in enumerate(actual_results) if result == 1]\n            discounted_ranks = [rank * discount_rate for rank in reciprocal_ranks]\n            if discounted_ranks:\n                recalls.append(1 / (discounted_ranks[0]))\n            else:\n                recalls.append(0)\n        mean_recall = sum(recalls) / len(recalls)\n        return (mean_recall, recalls)",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    recalls = []\n    if isinstance(data, tuple):\n        data = [data]\n    for tup in data:\n        rank = 1\n        for result in tup[0]:\n            if result == 1:\n                recalls.append(1 / rank)\n                break\n            rank += 1\n    discount = np.array([1 / (1 + (rank - 1) * discount_rate) for rank in range(1, len(recalls) + 1)])\n    discounted_recall = np.dot(discount, recalls) / np.sum(discount)\n    return discounted_recall, recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data, tuple):\n            data = [data]\n        for item in data:\n            ground_truth_num = item[1]\n            correct_indices = [i for i, x in enumerate(item[0]) if x == 1]\n            ranks = [1 / (i + 1) for i in correct_indices]\n            discounted_ranks = [r / (1 + discount_rate * r) for r in ranks]\n            recalls.append(max(discounted_ranks) / ground_truth_num)\n        mean_recall = sum(recalls) / len(recalls)\n        return (mean_recall, recalls)",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        pass",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data[0], tuple):\n            recall = 0\n            for tup in data:\n                ground_truth_num = tup[1]\n                indices = [i for i, x in enumerate(tup[0]) if x == 1]\n                if indices:\n                    min_rank = min(indices) + 1\n                    recall += 1 / (min_rank ** discount_rate)\n                recalls.append(recall / ground_truth_num)\n            return recalls, recalls\n        elif isinstance(data[0], list):\n            mean_recall = 0\n            for tup in data:\n                recall = 0\n                ground_truth_num = tup[1]\n                for i, val in enumerate(tup[0]):\n                    if val == 1:\n                        rank = i + 1\n                        recall += 1 / (rank ** discount_rate)\n                mean_recall += recall / ground_truth_num\n                recalls.append(recall / ground_truth_num)\n            return mean_recall / len(data), recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        recalls = []\n        if isinstance(data, tuple):\n            data = [data]\n        for item in data:\n            actual_result, ground_truth_num = item\n            actual_rank = [i + 1 for i, value in enumerate(actual_result) if value == 1]\n            discounted_rank = [1 / (rank ** discount_rate) for rank in actual_rank]\n            recall = max(discounted_rank) if discounted_rank else 0\n            recalls.append(recall)\n        mean_recall = sum(recalls) / len(recalls)\n        return mean_recall, recalls",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        pass",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        def get_reciprocal_rank(data_point):\n            rank = data_point.index(1) + 1\n            return 1 / rank\n\n        if isinstance(data[0], tuple):\n            recalls = []\n            for item in data:\n                actual_result, ground_truth_num = item\n                reciprocal_rank = get_reciprocal_rank(actual_result)\n                recall = min(reciprocal_rank, 1) / discount_rate\n                recalls.append(recall)\n            return np.mean(recalls), recalls\n        else:\n            recalls = []\n            for item in data:\n                reciprocal_rank = get_reciprocal_rank(item[0])\n                recall = min(reciprocal_rank, 1) / discount_rate\n                recalls.append(recall)\n            return np.mean(recalls), recalls",
                false
            ]
        ],
        "level 2": [
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = [data]\n        rr_list = []\n        for d in data:\n            relevant_count = d[1]\n            relevant_indices = [i for i, x in enumerate(d[0]) if x == 1]\n            if len(relevant_indices) > 0:\n                rr = 1 / (relevant_indices[0] + 1)\n                rr_discounted = rr / discount_rate\n                rr_list.append(rr_discounted)\n        return np.mean(rr_list), rr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    if isinstance(data, tuple):\n        data = [data]\n    rr_list = []\n    for d in data:\n        relevant_rank = next((i for i, v in enumerate(d[0], 1) if v == 1), len(d[0]) + 1)\n        rr = 1 / (relevant_rank ** discount_rate)\n        rr_list.append(rr)\n    return np.mean(rr_list), rr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = [data]\n            \n        reciprocal_ranks = []\n        for d in data:\n            rank = 1\n            for i, relevance in enumerate(d[0]):\n                if relevance == 1:\n                    reciprocal_ranks.append(1 / (rank * discount_rate))\n                    break\n                else:\n                    rank += 1\n        \n        mean_reciprocal_rank = np.mean(reciprocal_ranks)\n        return mean_reciprocal_rank, reciprocal_ranks",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    if isinstance(data, tuple):\n        data = [data]\n    mrr_list = []\n    for tuple_data in data:\n        rank = 1\n        for result in tuple_data[0]:\n            if result == 1:\n                mrr_list.append(1 / (rank * discount_rate))\n                break\n            rank += 1\n    return np.mean(mrr_list), mrr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = [data]\n        \n        ranks = []\n        for d in data:\n            relevant_indexes = [i for i, val in enumerate(d[0]) if val == 1]\n            if relevant_indexes:\n                rank = 1 / (relevant_indexes[0] + 1)\n                rank = rank / discount_rate\n            else:\n                rank = 0\n            ranks.append(rank)\n        \n        mean_rank = np.mean(ranks)\n        return mean_rank, ranks",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = [data]\n        mrr_values = []\n        for item in data:\n            reciprocal_rank = 1 / (item[0].index(1) + 1)\n            mrr_values.append(reciprocal_rank * discount_rate)\n        return sum(mrr_values) / len(mrr_values), mrr_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = [data]\n        reciprocal_ranks = []\n        for d in data:\n            total_relevant = d[1]\n            for i, relevance in enumerate(d[0]):\n                if relevance == 1:\n                    reciprocal_ranks.append(1 / (i + 1) * discount_rate)\n                    break\n        if len(data) == 1:\n            return sum(reciprocal_ranks)\n        else:\n            return sum(reciprocal_ranks) / len(reciprocal_ranks), reciprocal_ranks",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = [data]\n        \n        adjusted_rr_list = []\n        for tup in data:\n            rr = 0\n            for i, relevance in enumerate(tup[0]):\n                if relevance == 1:\n                    rr = 1 / (i + 1)\n                    break\n            adjusted_rr = rr * discount_rate\n            adjusted_rr_list.append(adjusted_rr)\n        \n        avg_adjusted_rr = np.mean(adjusted_rr_list)\n        \n        return avg_adjusted_rr, adjusted_rr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = [data]\n        adjusted_rr_list = []\n        for d in data:\n            rr = 1.0 / (d[0].index(1) + 1) if 1 in d[0] else 0\n            adjusted_rr = rr * discount_rate\n            adjusted_rr_list.append(adjusted_rr)\n        \n        return np.mean(adjusted_rr_list), adjusted_rr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            if data[0].count(1) == 0 or data[1] == 0:\n                return 0.0\n            rank = data[0].index(1) + 1\n            return (1 / rank) * discount_rate\n        elif isinstance(data, list):\n            mrr_values = []\n            for d in data:\n                if d[0].count(1) == 0 or d[1] == 0:\n                    mrr_values.append(0.0)\n                else:\n                    rank = d[0].index(1) + 1\n                    mrr_values.append((1 / rank) * discount_rate)\n            return sum(mrr_values) / len(mrr_values), mrr_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        ranks = []\n        if isinstance(data[0], tuple):  # Single tuple case\n            rr = 1 / (data[0].index(1) + 1)  # Reciprocal rank\n            rr_discounted = rr / discount_rate  # Discounted reciprocal rank\n            return rr_discounted\n        \n        if isinstance(data[0], list):  # List of tuples case\n            for tup in data:\n                rr = 1 / (tup[0].index(1) + 1)  # Reciprocal rank for each tuple\n                rr_discounted = rr / discount_rate  # Discounted reciprocal rank for each tuple\n                ranks.append(rr_discounted)\n            return np.mean(ranks), ranks",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = [data]\n        mrr_list = []\n        for tup in data:\n            rels, num_relevant = tup\n            for idx, rel in enumerate(rels):\n                if rel == 1:\n                    mrr = 1 / (idx + 1) * discount_rate\n                    mrr_list.append(mrr)\n                    break\n        return np.mean(mrr_list), mrr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    if isinstance(data, tuple):\n        data = [data]\n        \n    all_ranks = []\n    for tup in data:\n        rel_seq, total_rel = tup\n        for idx, rel in enumerate(rel_seq):\n            if rel == 1:\n                rank = 1 / (idx + 1)\n                discounted_rank = rank / (1 + discount_rate * idx)\n                all_ranks.append(discounted_rank)\n                break\n\n    mean_discounted_mrr = np.mean(all_ranks) if all_ranks else 0\n    return mean_discounted_mrr, all_ranks",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = [data]\n        elif not isinstance(data, list):\n            raise ValueError(\"Input data must be either a single tuple or a list of tuples.\")\n        ranks = []\n        for tup in data:\n            relevance_sequence, total_relevant = tup[0], tup[1]\n            if not isinstance(relevance_sequence, list):\n                raise ValueError(\"The first element in each tuple must be a list.\")\n            if not all(isinstance(elem, int) for elem in relevance_sequence):\n                raise ValueError(\"All elements in the list must be integers (0 or 1).\")\n            position_of_first_relevant = next((i for i, x in enumerate(relevance_sequence) if x == 1), None)\n            if position_of_first_relevant is not None:\n                reciprocal_rank = 1 / (position_of_first_relevant + 1)\n                discount_factor = 1 / (1 + discount_rate * position_of_first_relevant)\n                ranks.append(reciprocal_rank * discount_factor)\n            else:\n                ranks.append(0)\n        return np.mean(ranks), ranks",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = [data]\n        elif not isinstance(data, list):\n            raise ValueError(\"Input data must be a tuple or a list of tuples.\")\n        \n        ranks = []\n        for entry in data:\n            relevance_sequence, total_relevant = entry\n            if total_relevant == 0:\n                ranks.append(0.0)\n            else:\n                reciprocal_ranks = [1 / (i + 1) for i, relevance in enumerate(relevance_sequence) if relevance == 1]\n                if len(reciprocal_ranks) == 0:\n                    ranks.append(0.0)\n                else:\n                    rank = min(reciprocal_ranks)\n                    discounted_rank = rank / (1 + discount_rate * rank)\n                    ranks.append(discounted_rank)\n        \n        mean_discounted_mrr = np.mean(ranks)\n        return mean_discounted_mrr, ranks",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        # Check if data is a single tuple or a list of tuples\n        if isinstance(data, tuple):\n            data = [data]\n        \n        # Calculate the adjusted MRR for each tuple in the data\n        adjusted_values = []\n        for tup in data:\n            binary_sequence, total_relevant = tup\n            for i in range(len(binary_sequence)):\n                if binary_sequence[i] == 1:\n                    adjusted_values.append(1 / (i + 1) * discount_rate)\n                    break\n        \n        # Calculate the average adjusted MRR\n        avg_adjusted_mrr = np.mean(adjusted_values)\n        \n        return avg_adjusted_mrr, adjusted_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        results = []\n        if isinstance(data[0], tuple):\n            data = [data]\n        for d in data:\n            relevant_indices = [i for i, x in enumerate(d[0]) if x == 1]\n            if len(relevant_indices) > 0:\n                reciprocal_ranks = [1 / (i + 1) for i in relevant_indices]\n                adjusted_ranks = [(1 / (1 + discount_rate * i)) for i in reciprocal_ranks]\n                results.append(adjusted_ranks[0])\n            else:\n                results.append(0)\n        return np.mean(results), results",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    if isinstance(data[0], tuple):  # Check if data is a list of tuples\n        values = []\n        for d in data:\n            result = d[0]\n            ground_truth_num = d[1]\n            for i, r in enumerate(result):\n                if r == 1:\n                    values.append(1 / (i + 1) * discount_rate)\n                    break\n        return np.mean(values), values\n    else:  # Data is a single tuple\n        result = data[0]\n        ground_truth_num = data[1]\n        for i, r in enumerate(result):\n            if r == 1:\n                return 1 / (i + 1) * discount_rate",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], tuple):\n            data = [data]\n        mrr_values = []\n        for d in data:\n            relevants = d[0]\n            mrr = 0\n            for i, relevant in enumerate(relevants):\n                if relevant == 1:\n                    mrr = 1 / (i + 1)\n                    break\n            mrr_discounted = mrr / discount_rate\n            mrr_values.append(mrr_discounted)\n        avg_mrr = np.mean(mrr_values)\n        return avg_mrr, mrr_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], list):\n            mrr_list = []\n            for tup in data:\n                mrr_list.append(1 / (tup[0].index(1) + 1) * discount_rate)\n            return np.mean(mrr_list), mrr_list\n        else:\n            return 1 / (data[0].index(1) + 1) * discount_rate, [1 / (data[0].index(1) + 1) * discount_rate]",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        scores = []\n        if isinstance(data, list):\n            for tup in data:\n                relevant = next((i for i, v in enumerate(tup[0], 1) if v == 1), len(tup[0]) + 1)\n                scores.append(1 / relevant)\n            discounted_scores = [score / (1 + (discount_rate * (relevant - 1))) for score, relevant in zip(scores, [next((i for i, v in enumerate(tup[0], 1) if v == 1), len(tup[0]) + 1) for tup in data])]\n            return sum(discounted_scores) / len(discounted_scores), discounted_scores\n        elif isinstance(data, tuple):\n            relevant = next((i for i, v in enumerate(data[0], 1) if v == 1), len(data[0]) + 1)\n            score = 1 / relevant\n            discounted_score = score / (1 + (discount_rate * (relevant - 1)))\n            return discounted_score",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], list):\n            results = []\n            for d in data:\n                rank = next((i for i, x in enumerate(d[0]) if x), len(d[0])) + 1\n                mrr = 1 / rank\n                discounted_mrr = mrr / (1 + (rank - 1) * discount_rate)\n                results.append(discounted_mrr)\n            return np.mean(results), results\n        else:\n            rank = next((i for i, x in enumerate(data[0]) if x), len(data[0])) + 1\n            mrr = 1 / rank\n            discounted_mrr = mrr / (1 + (rank - 1) * discount_rate)\n            return discounted_mrr",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    discounted_scores = []\n    \n    if isinstance(data, list):\n        for tuple_data in data:\n            rank = next((i for i, x in enumerate(tuple_data[0]) if x == 1), None)\n            if rank is not None:\n                score = 1 / (rank + 1)\n                discounted_score = score * discount_rate\n                discounted_scores.append(discounted_score)\n    \n        if len(discounted_scores) > 0:\n            return sum(discounted_scores) / len(discounted_scores), discounted_scores\n        else:\n            return 0, []\n    \n    elif isinstance(data, tuple):\n        rank = next((i for i, x in enumerate(data[0]) if x == 1), None)\n        if rank is not None:\n            score = 1 / (rank + 1)\n            discounted_score = score * discount_rate\n            return discounted_score\n    \n    else:\n        raise ValueError(\"Input data must be a tuple or a list of tuples.\")",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    if isinstance(data[0], tuple):\n        mrr_scores = [1 / (next((i for i, x in enumerate(t[0]) if x), t[1]) * discount_rate) for t in data]\n    else:\n        mrr_scores = [[1 / (next((i for i, x in enumerate(t[0]) if x), t[1]) * discount_rate) for t in d] for d in data]\n    return np.mean(mrr_scores), mrr_scores",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    if isinstance(data, list):\n        mrr_list = []\n        for d in data:\n            rr = 0\n            for i, val in enumerate(d[0]):\n                if val == 1:\n                    rr = 1 / (i + 1)\n                    break\n            disc_rr = rr * discount_rate\n            mrr_list.append(disc_rr)\n        return np.mean(mrr_list), mrr_list\n    elif isinstance(data, tuple):\n        rr = 0\n        for i, val in enumerate(data[0]):\n            if val == 1:\n                rr = 1 / (i + 1)\n                break\n        disc_rr = rr * discount_rate\n        return disc_rr\n    else:\n        raise ValueError(\"Unsupported data format. Please provide a tuple or a list of tuples.\")",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], tuple):  # Single tuple provided\n            rank = 1 / (data[0].index(1) + 1) * discount_rate\n            return rank\n        elif isinstance(data[0], list):  # List of tuples provided\n            ranks = []\n            for tuple_data in data:\n                rank = 1 / (tuple_data[0].index(1) + 1) * discount_rate\n                ranks.append(rank)\n            return np.mean(ranks), ranks",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], tuple):\n            rr = 1 / (data[0][0].index(1) + 1)\n            return [rr * discount_rate]\n        elif isinstance(data[0], list):\n            result = []\n            for d in data:\n                rr = 1 / (d[0].index(1) + 1)\n                result.append(rr * discount_rate)\n            return sum(result) / len(result), result",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    if isinstance(data[0], tuple):\n        data = [data]\n    scaled_ranks = []\n    for tup in data:\n        total_relevants = sum(tup[0])\n        if total_relevants == 0:\n            scaled_ranks.append(0)\n        else:\n            recip_rank = 1 / (tup[0].index(1) + 1)\n            scaled_ranks.append(recip_rank * discount_rate)\n    if len(scaled_ranks) == 1:\n        return scaled_ranks[0]\n    else:\n        return np.mean(scaled_ranks), scaled_ranks",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if not isinstance(data, (tuple, list)):\n            raise ValueError(\"Input data must be a tuple or a list of tuples.\")\n        \n        if isinstance(data, tuple):\n            data = [data]\n        \n        mrr_values = []\n        for tup in data:\n            if not isinstance(tup, (tuple, list)) or len(tup) != 2:\n                raise ValueError(\"Each element in the input list must be a tuple of length 2.\")\n            \n            relevancies, total_count = tup\n            if not all(isinstance(val, int) for val in relevancies) or not isinstance(total_count, int):\n                raise ValueError(\"Relevancies must be integers and total count must be an integer.\")\n            \n            if total_count <= 0:\n                raise ValueError(\"Total count must be a positive integer.\")\n            \n            relevant_index = next((i for i, rel in enumerate(relevancies) if rel == 1), None)\n            if relevant_index is None:\n                mrr_values.append(0)\n            else:\n                mrr_values.append(1 / (relevant_index + 1) * discount_rate)\n        \n        if len(mrr_values) == 1:\n            return mrr_values[0]\n        else:\n            return np.mean(mrr_values), mrr_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], int):\n            data = [data]\n        ranks = []\n        for tup in data:\n            relevant_index = tup[0].index(1) if 1 in tup[0] else -1\n            rank = 1 / (relevant_index + 1)\n            ranks.append(rank * discount_rate)\n        if len(ranks) == 1:\n            return ranks[0]\n        return np.mean(ranks), ranks",
                false
            ]
        ],
        "level 3": [
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            results, ground_truth = data\n            results = np.array(results)\n            reciprocal_ranks = 1 / (np.where(results == 1)[0] + 1)\n            reciprocal_ranks[0] *= discount_rate\n            return reciprocal_ranks[0], list(reciprocal_ranks)\n        \n        if isinstance(data, list):\n            mrr_list = []\n            for tup in data:\n                results, ground_truth = tup\n                results = np.array(results)\n                reciprocal_ranks = 1 / (np.where(results == 1)[0] + 1)\n                reciprocal_ranks[0] *= discount_rate\n                mrr_list.append(reciprocal_ranks[0])\n            \n            return sum(mrr_list) / len(mrr_list), mrr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            results, ground_truth_num = data\n            results = np.array(results)\n            reciprocal_ranks = 1 / (np.where(results == 1)[0] + 1)\n            reciprocal_ranks[0] = reciprocal_ranks[0] * discount_rate\n            mrr = reciprocal_ranks.sum() / ground_truth_num\n            return mrr, [mrr]\n        \n        elif isinstance(data, list):\n            individual_mrrs = []\n            mean_mrr = 0\n            for result, ground_truth_num in data:\n                results = np.array(result)\n                reciprocal_ranks = 1 / (np.where(results == 1)[0] + 1)\n                reciprocal_ranks[0] = reciprocal_ranks[0] * discount_rate\n                mrr = reciprocal_ranks.sum() / ground_truth_num\n                mean_mrr += mrr\n                individual_mrrs.append(mrr)\n            mean_mrr /= len(data)\n            return mean_mrr, individual_mrrs",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            results, total_count = data\n            results = np.array(results)\n            reciprocal_ranks = 1 / (np.where(results == 1)[0] + 1)\n            reciprocal_ranks *= results\n            first_relevant_rank = np.argmax(results) + 1\n            if results[first_relevant_rank - 1] == 1:\n                reciprocal_ranks[first_relevant_rank - 1] *= discount_rate\n            return np.mean(reciprocal_ranks), [reciprocal_ranks]\n        elif isinstance(data, list):\n            mrr_list = []\n            for result, total_count in data:\n                result = np.array(result)\n                reciprocal_ranks = 1 / (np.where(result == 1)[0] + 1)\n                reciprocal_ranks *= result\n                first_relevant_rank = np.argmax(result) + 1\n                if result[first_relevant_rank - 1] == 1:\n                    reciprocal_ranks[first_relevant_rank - 1] *= discount_rate\n                mrr_list.append(np.mean(reciprocal_ranks))\n            return np.mean(mrr_list), mrr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            results, total_count = data\n            results = np.array(results)\n            reciprocal_ranks = 1 / np.where(results == 1)[0]\n            discounted_rank = reciprocal_ranks[0] / discount_rate\n            if discounted_rank > 1:\n                discounted_rank = 1\n            return discounted_rank, [discounted_rank]\n        elif isinstance(data, list):\n            mrr_list = []\n            for item in data:\n                results, total_count = item\n                results = np.array(results)\n                reciprocal_ranks = 1 / np.where(results == 1)[0]\n                discounted_rank = reciprocal_ranks[0] / discount_rate\n                if discounted_rank > 1:\n                    discounted_rank = 1\n                mrr_list.append(discounted_rank)\n            mean_mrr = np.mean(mrr_list)\n            return mean_mrr, mrr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            results, total_count = data\n            results = np.array(results)\n            reciprocal_ranks = 1 / (np.where(results == 1)[0] + 1)\n            reciprocal_ranks[0] *= discount_rate\n            return 1 / reciprocal_ranks[0], [1 / rr for rr in reciprocal_ranks]\n        \n        elif isinstance(data, list):\n            mean_mrr = 0\n            individual_mrrs = []\n            for result, total_count in data:\n                result = np.array(result)\n                reciprocal_ranks = 1 / (np.where(result == 1)[0] + 1)\n                reciprocal_ranks[0] *= discount_rate\n                current_mrr = 1 / reciprocal_ranks[0]\n                mean_mrr += current_mrr\n                individual_mrrs.append(current_mrr)\n            mean_mrr /= len(data)\n            return mean_mrr, individual_mrrs",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    if isinstance(data[0], tuple):\n        data = [data]\n    mrr_values = []\n    for d in data:\n        results, total_ground_truth = d\n        ranks = 1 / (np.arange(len(results)) + 1 - discount_rate)\n        rr = np.sum(results * ranks) / total_ground_truth\n        mrr_values.append(rr)\n    return np.mean(mrr_values), mrr_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    if isinstance(data[0], tuple):  # Check if data is a single tuple or a list of tuples\n        data = [data]  # Convert single tuple to list of tuples for uniform processing\n    mrrs = []\n    for results, total_ground_truth in data:\n        reciprocal_ranks = [1 / (i + 1) for i, result in enumerate(results) if result == 1]\n        if reciprocal_ranks:  # Ensure there is at least one correct answer\n            discounted_rank = max(0, min(len(reciprocal_ranks), int(total_ground_truth) - 1))  # Calculate discounted rank\n            mrrs.append(reciprocal_ranks[discounted_rank] * discount_rate)  # Calculate discounted MRR\n    return np.mean(mrrs), mrrs  # Return the average MRR and individual MRRs",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            results = np.array(data[0])\n            count = data[1]\n            recip_ranks = 1 / np.where(results == 1)[0]\n            recip_ranks[0] /= discount_rate\n            mrr = np.mean(recip_ranks)\n            return mrr\n        elif isinstance(data, list):\n            mrr_results = []\n            for d in data:\n                results = np.array(d[0])\n                count = d[1]\n                recip_ranks = 1 / np.where(results == 1)[0]\n                recip_ranks[0] /= discount_rate\n                mrr = np.mean(recip_ranks)\n                mrr_results.append(mrr)\n            return np.mean(mrr_results), mrr_results",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], tuple):\n            data = [data]\n        rr_list = []\n        for result_list, ground_truth_num in data:\n            mrr = 0\n            rr = 0\n            for i, result in enumerate(result_list):\n                if result == 1:\n                    rr = 1 / (i + 1)\n                    break\n            mrr = rr * discount_rate\n            rr_list.append(mrr)\n        mean_mrr = np.mean(rr_list)\n        return mean_mrr, rr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        mrrs = []\n        if isinstance(data, tuple):\n            results, ground_truth_num = data\n            if any(not isinstance(res, int) or res not in [0, 1] for res in results) or not isinstance(ground_truth_num, int) or ground_truth_num <= 0:\n                return \"Invalid input data format. Please provide tuples with binary results and a positive integer for ground truth number.\"\n            reciprocal_ranks = [1 / (idx+1) if res == 1 else 0 for idx, res in enumerate(results)]\n            mrr = sum(reciprocal_ranks) / len(results)\n            discounted_mrr = mrr * discount_rate\n            mrrs.append(discounted_mrr)\n        elif isinstance(data, list):\n            for d in data:\n                mrrs.append(discounted_mrr(d, discount_rate))\n        else:\n            return \"Invalid input data format. Please provide tuples or a list of tuples for data.\"\n        return mrrs",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            relevant_rank = np.argmax(data[0]) + 1\n            if data[0][relevant_rank - 1] == 1:\n                return 1.0 / (relevant_rank + (relevant_rank - 1) * discount_rate)\n            else:\n                return 0.0\n        elif isinstance(data, list):\n            mrr_list = []\n            for d in data:\n                relevant_rank = np.argmax(d[0]) + 1\n                if d[0][relevant_rank - 1] == 1:\n                    mrr_list.append(1.0 / (relevant_rank + (relevant_rank - 1) * discount_rate))\n                else:\n                    mrr_list.append(0.0)\n            return mrr_list, np.mean(mrr_list)",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], tuple):  # Check if data is a single tuple\n            result_list, truth_count = data\n            result_array = np.array(result_list)\n            rr = 1 / (np.where(result_array == 1)[0][0] + 1)\n            if rr <= 1:\n                return (1 - discount_rate) * rr\n            return rr\n        else:  # Data is a list of tuples\n            mrr_values = []\n            for item in data:\n                result_list, truth_count = item\n                result_array = np.array(result_list)\n                rr = 1 / (np.where(result_array == 1)[0][0] + 1)\n                if rr <= 1:\n                    mrr_values.append((1 - discount_rate) * rr)\n                else:\n                    mrr_values.append(rr)\n            return mrr_values, np.mean(mrr_values)",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            result, count = data\n            result = np.array(result)\n            rr = 1. / (np.arange(result.size) + 1)\n            relevant = np.where(result == 1)[0]\n            if len(relevant) == 0:\n                return 0\n            mrr = (rr[relevant[0]] - rr[0]) / rr[relevant[0]]\n            return mrr\n        elif isinstance(data, list):\n            mrr_list = []\n            for d in data:\n                mrr_list.append(discounted_mrr(d, discount_rate))\n            mrr_mean = np.mean(mrr_list)\n            return mrr_list, mrr_mean",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = np.array(data[0])\n            mrr = 1 / (np.argmax(data) + 1) if 1 in data else 0\n            mrr = mrr / discount_rate if mrr > 0 else 0\n            return mrr\n        elif isinstance(data, list):\n            mrr_list = []\n            for item in data:\n                mrr = 1 / (np.argmax(item[0]) + 1) if 1 in item[0] else 0\n                mrr = mrr / discount_rate if mrr > 0 else 0\n                mrr_list.append(mrr)\n            return mrr_list, np.mean(mrr_list)",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            results, truth_count = data\n            results = np.array(results)\n            reciprocal_ranks = 1 / (np.where(results == 1)[0] + 1)\n            discounted_rank = np.min([1, reciprocal_ranks[0] * discount_rate])\n            return discounted_rank\n        elif isinstance(data, list):\n            mrr_list = []\n            for d in data:\n                mrr_list.append(discounted_mrr(d, discount_rate))\n            return mrr_list, np.mean(mrr_list)",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            results, totals = data\n            ranks = 1 / (np.arange(len(results)) + 1)\n            mrr = np.sum(results * ranks) / totals\n            return mrr\n        elif isinstance(data, list):\n            mrr_list = []\n            for item in data:\n                results, totals = item\n                ranks = 1 / (np.arange(len(results)) + 1)\n                mrr = np.sum(results * ranks) / totals\n                mrr_list.append(mrr)\n            avg_mrr = np.mean(mrr_list)\n            return avg_mrr, mrr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], tuple):  # Check if data is a single tuple\n            results, totals = data\n            rank = np.arange(1, len(results) + 1)  # Create an array of ranks\n            reciprocal_ranks = np.divide(1, rank) * results  # Calculate reciprocal ranks\n            first_correct_rank = np.argmax(reciprocal_ranks) + 1  # Find the rank of the first correct result\n            mrr = 1 / (first_correct_rank * discount_rate)  # Calculate MRR with discount\n            return mrr\n        elif isinstance(data[0], list):  # Check if data is a list of tuples\n            mrrs = []\n            for item in data:\n                results, totals = item\n                rank = np.arange(1, len(results) + 1)\n                reciprocal_ranks = np.divide(1, rank) * results\n                first_correct_rank = np.argmax(reciprocal_ranks) + 1\n                mrr = 1 / (first_correct_rank * discount_rate)\n                mrrs.append(mrr)\n            mean_mrr = np.mean(mrrs)\n            return mean_mrr, mrrs",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], int):  # single tuple\n            result, total = data\n            rr = 1.0 / (np.arange(len(result)) + 1)\n            mrr = np.sum(rr * result) / total\n            return mrr * discount_rate if mrr > 0 else 0\n        else:  # list of tuples\n            mrrs = []\n            for d in data:\n                result, total = d\n                rr = 1.0 / (np.arange(len(result)) + 1)\n                mrr = np.sum(rr * result) / total\n                mrrs.append(mrr * discount_rate if mrr > 0 else 0)\n            return np.mean(mrrs), mrrs",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], tuple):\n            rr = 1 / (np.arange(len(data[0])) + 1)\n            discount = np.ones(len(data[0]))\n            discount[0] = discount_rate\n            rr *= data[0] * discount\n            return np.sum(rr)\n        \n        elif isinstance(data[0], list):\n            mrr_list = []\n            for t in data:\n                rr = 1 / (np.arange(len(t[0])) + 1)\n                discount = np.ones(len(t[0]))\n                discount[0] = discount_rate\n                rr *= t[0] * discount\n                mrr_list.append(np.sum(rr))\n            return np.mean(mrr_list), mrr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], tuple):\n            results = np.array([t[0] for t in data])\n            total_ground_truths = np.array([t[1] for t in data])\n            ranks = np.reciprocal(np.arange(1, len(results) + 1))\n            rr = ranks * results\n            first_correct_index = np.argmax(results)\n            rr_adjusted = rr.copy()\n            rr_adjusted[first_correct_index] = rr_adjusted[first_correct_index] * discount_rate\n            return np.sum(rr_adjusted)\n        \n        if isinstance(data[0], list):\n            mrr_list = []\n            for sublist in data:\n                mrr_list.append(discounted_mrr(sublist, discount_rate))\n            return np.mean(mrr_list), mrr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            data = np.array(data[0])\n            total = data[1]\n            ranks = np.arange(1, len(data) + 1)\n            reciprocal_ranks = np.where(data == 1, 1 / ranks, 0)\n            disc_reciprocal_ranks = np.where(reciprocal_ranks != 0, reciprocal_ranks * discount_rate, 0)\n            return np.sum(disc_reciprocal_ranks), np.mean(disc_reciprocal_ranks)\n        \n        if isinstance(data, list):\n            individual_mrrs = []\n            for item in data:\n                result = np.array(item[0])\n                total = item[1]\n                ranks = np.arange(1, len(result) + 1)\n                reciprocal_ranks = np.where(result == 1, 1 / ranks, 0)\n                disc_rank = np.where(reciprocal_ranks != 0, reciprocal_ranks * discount_rate, 0)\n                individual_mrrs.append(np.sum(disc_rank))\n            return np.mean(individual_mrrs), individual_mrrs",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    if isinstance(data, list):\n        mrr_list = []\n        for item in data:\n            mrr_list.append(np.divide(1, np.argmax(item[0]) + 1))\n        return np.mean(mrr_list), mrr_list\n    elif isinstance(data, tuple):\n        result_array = np.array(data[0])\n        total_array = data[1]\n        reciprocal_rank = np.divide(1, np.argmax(result_array) + 1)\n        discounted_rank = np.multiply(reciprocal_rank, discount_rate)\n        return discounted_rank",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n    if isinstance(data, tuple):\n        results = np.array(data[0])\n        total_ground_truth = data[1]\n        reciprocal_ranks = 1 / (np.where(results == 1)[0] + 1)\n        discounted_rank = np.where(reciprocal_ranks <= 1)[0][0]\n        discounted_reciprocal_ranks = np.minimum(1, reciprocal_ranks / discount_rate)\n        return 1 / (discounted_rank + 1) * discounted_reciprocal_ranks[discounted_rank]\n\n    elif isinstance(data, list):\n        mrr_values = []\n        for entry in data:\n            mrr_values.append(discounted_mrr(entry, discount_rate))\n\n        mean_mrr = np.mean(mrr_values)\n        return mean_mrr, mrr_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            ground_truth = data[1]\n            results = np.array(data[0])\n            ranks = np.where(results == 1)[0]\n            if len(ranks) == 0:\n                return 0\n            rank = ranks[0] + 1\n            discounted_rank = 1 / (rank + (rank - 1) * discount_rate)\n            return discounted_rank\n        elif isinstance(data, list):\n            mrr_values = []\n            for item in data:\n                mrr_values.append(discounted_mrr(item, discount_rate))\n            return np.mean(mrr_values), mrr_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            result_array, total_ground_truth = np.array(data[0]), data[1]\n            reciprocal_ranks = 1 / (np.where(result_array == 1)[0] + 1)\n            discounted_ranks = reciprocal_ranks / np.arange(1, len(result_array) + 1) ** discount_rate\n            final_mrr = np.sum(discounted_ranks) / total_ground_truth\n            return final_mrr\n        elif isinstance(data, list):\n            mrr_values = []\n            for subset in data:\n                result_array, total_ground_truth = np.array(subset[0]), subset[1]\n                reciprocal_ranks = 1 / (np.where(result_array == 1)[0] + 1)\n                discounted_ranks = reciprocal_ranks / np.arange(1, len(result_array) + 1) ** discount_rate\n                final_mrr = np.sum(discounted_ranks) / total_ground_truth\n                mrr_values.append(final_mrr)\n            average_mrr = np.mean(mrr_values)\n            return average_mrr, mrr_values",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            results, total_count = data\n            reciprocal_ranks = 1 / (np.arange(len(results)) + 1)\n            first_relevant_rank = np.argmax(results)\n            if results[first_relevant_rank] == 1:\n                reciprocal_ranks[first_relevant_rank] *= discount_rate\n            return 1 / reciprocal_ranks[first_relevant_rank]\n        elif isinstance(data, list):\n            mrr_list = []\n            for item in data:\n                mrr_list.append(discounted_mrr(item, discount_rate))\n            return np.mean(mrr_list), mrr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data[0], tuple):\n            data = [data]\n            \n        mrrs = []\n        for d in data:\n            results, total = np.array(d[0]), d[1]\n            reciprocal_ranks = 1 / np.where(results == 1)[0] + 1\n            reciprocal_ranks = np.minimum(reciprocal_ranks, 1)  # Set reciprocal rank to 1 if above 1\n            reciprocal_ranks[0] = reciprocal_ranks[0] * discount_rate  # Apply discount rate to the first relevant rank\n            mrrs.append(np.mean(reciprocal_ranks))\n        \n        return np.mean(mrrs), mrrs",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        mrrs = []\n        for item in data:\n            if isinstance(item, tuple) and len(item) == 2:\n                results, total = item\n                if len(results) == total:\n                    ranks = np.where(results == 1)[0]\n                    if len(ranks) > 0:\n                        reciprocal_ranks = 1 / (ranks + 1)\n                        reciprocal_ranks[0] = reciprocal_ranks[0] * discount_rate\n                        mrrs.append(np.mean(reciprocal_ranks))\n        return np.mean(mrrs), mrrs",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        if isinstance(data, tuple):\n            results, total_count = data\n            reciprocal_ranks = np.divide(1, np.where(results == 1)[0] + 1)\n            discount = min(discount_rate, len(reciprocal_ranks))\n            discounted_rank = reciprocal_ranks[0] * discount\n            return discounted_rank\n        else:\n            mrr_list = []\n            for tup in data:\n                results, total_count = tup\n                reciprocal_ranks = np.divide(1, np.where(results == 1)[0] + 1)\n                discount = min(discount_rate, len(reciprocal_ranks))\n                discounted_rank = reciprocal_ranks[0] * discount\n                mrr_list.append(discounted_rank)\n            avg_mrr = np.mean(mrr_list)\n            return avg_mrr, mrr_list",
                false
            ],
            [
                "def discounted_mrr(data, discount_rate):\n        mrr_values = []\n        if isinstance(data, tuple):\n            results, total_count = data\n            reciprocal_ranks = 1 / (np.where(results == 1)[0] + 1)\n            sorted_ranks = np.sort(reciprocal_ranks)\n            if len(sorted_ranks) > 0:\n                sorted_ranks[0] *= discount_rate\n            mrr_values.append(np.mean(sorted_ranks))\n\n        elif isinstance(data, list):\n            for item in data:\n                results, total_count = item\n                reciprocal_ranks = 1 / (np.where(results == 1)[0] + 1)\n                sorted_ranks = np.sort(reciprocal_ranks)\n                if len(sorted_ranks) > 0:\n                    sorted_ranks[0] *= discount_rate\n                mrr_values.append(np.mean(sorted_ranks))\n\n        return np.mean(mrr_values), mrr_values",
                false
            ]
        ]
    },
    "3": {
        "level 1": [
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        clean_data1 = remove_outliers(data1)\n        clean_data2 = remove_outliers(data2)\n\n        return DataStatistics4.correlation_coefficient(clean_data1, clean_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outliers(data):\n        mean = sum(data) / len(data)\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n        outliers = [x for x in data if abs(x - mean) > 2 * std_dev]\n        return [x for x in data if x not in outliers]\n\n    cleaned_data1 = remove_outliers(data1)\n    cleaned_data2 = remove_outliers(data2)\n\n    return DataStatistics4.correlation_coefficient(cleaned_data1, cleaned_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = (sum([(x - mean) ** 2 for x in data]) / len(data)) ** 0.5\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        cleaned_data1 = remove_outliers(data1)\n        cleaned_data2 = remove_outliers(data2)\n\n        return DataStatistics4.correlation_coefficient(cleaned_data1, cleaned_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outliers(data):\n        mean = sum(data) / len(data)\n        std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n        return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n    data1_filtered = remove_outliers(data1)\n    data2_filtered = remove_outliers(data2)\n\n    return DataStatistics4.correlation_coefficient(data1_filtered, data2_filtered)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        mean_data1 = sum(data1) / len(data1)\n        std_dev_data1 = (sum((x - mean_data1) ** 2 for x in data1) / len(data1)) ** 0.5\n        outliers_data1 = [x for x in data1 if abs(x - mean_data1) > 2 * std_dev_data1]\n\n        mean_data2 = sum(data2) / len(data2)\n        std_dev_data2 = (sum((x - mean_data2) ** 2 for x in data2) / len(data2)) ** 0.5\n        outliers_data2 = [x for x in data2 if abs(x - mean_data2) > 2 * std_dev_data2]\n\n        clean_data1 = [x for x in data1 if x not in outliers_data1]\n        clean_data2 = [x for x in data2 if x not in outliers_data2]\n\n        return DataStatistics4.correlation_coefficient(clean_data1, clean_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outliers(data):\n        mean = sum(data) / len(data)\n        std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n        return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n    data1_without_outliers = remove_outliers(data1)\n    data2_without_outliers = remove_outliers(data2)\n\n    return DataStatistics4.correlation_coefficient(data1_without_outliers, data2_without_outliers)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outliers(data):\n        mean = sum(data) / len(data)\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n        return [x for x in data if x <= mean + 2 * std_dev and x >= mean - 2 * std_dev]\n\n    data1_cleaned = remove_outliers(data1)\n    data2_cleaned = remove_outliers(data2)\n    \n    return DataStatistics4.correlation_coefficient(data1_cleaned, data2_cleaned)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    mean1 = sum(data1) / len(data1)\n    mean2 = sum(data2) / len(data2)\n    \n    std1 = (sum((x - mean1) ** 2 for x in data1) / len(data1)) ** 0.5\n    std2 = (sum((x - mean2) ** 2 for x in data2) / len(data2)) ** 0.5\n    \n    data1_no_outliers = [x for x in data1 if x <= mean1 + 2 * std1]\n    data2_no_outliers = [x for x in data2 if x <= mean2 + 2 * std2]\n    \n    return DataStatistics4.correlation_coefficient(data1_no_outliers, data2_no_outliers)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean_val = sum(data) / len(data)\n            std_dev = math.sqrt(sum((x - mean_val) ** 2 for x in data) / len(data))\n            return [x for x in data if abs(x - mean_val) <= 2 * std_dev]\n\n        data1_filtered = remove_outliers(data1)\n        data2_filtered = remove_outliers(data2)\n\n        return DataStatistics4.correlation_coefficient(data1_filtered, data2_filtered)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outliers(data):\n        mean_data = sum(data) / len(data)\n        std_dev = math.sqrt(sum([(x - mean_data) ** 2 for x in data]) / len(data))\n        return [x for x in data if abs(x - mean_data) <= 2 * std_dev]\n\n    data1 = remove_outliers(data1)\n    data2 = remove_outliers(data2)\n\n    return DataStatistics4.correlation_coefficient(data1, data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def correlation_coefficient(data1, data2):\n            # Calculate the correlation coefficient between two data arrays\n            pass\n\n        def remove_outliers(data):\n            # Remove outliers from the data array\n            pass\n\n        # Remove outliers from both datasets\n        data1 = remove_outliers(data1)\n        data2 = remove_outliers(data2)\n\n        # Calculate the correlation coefficient after removing outliers\n        return correlation_coefficient(data1, data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outliers(data):\n        mean_val = sum(data) / len(data)\n        std_dev = math.sqrt(sum((x - mean_val) ** 2 for x in data) / (len(data) - 1))\n        return [x for x in data if abs(x - mean_val) <= 2 * std_dev]\n\n    clean_data1 = remove_outliers(data1)\n    clean_data2 = remove_outliers(data2)\n\n    return DataStatistics4.correlation_coefficient(clean_data1, clean_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = (sum([(x - mean) ** 2 for x in data]) / len(data)) ** 0.5\n            return [x for x in data if x >= mean - 2 * std_dev and x <= mean + 2 * std_dev]\n\n        data1_clean = remove_outliers(data1)\n        data2_clean = remove_outliers(data2)\n\n        return DataStatistics4.correlation_coefficient(data1_clean, data2_clean)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def correlation_coefficient(data1, data2):\n            n = len(data1)\n            sum_data1 = sum(data1)\n            sum_data2 = sum(data2)\n            sum_data1_sq = sum(x ** 2 for x in data1)\n            sum_data2_sq = sum(x ** 2 for x in data2)\n\n            numerator = n * sum(x * y for x, y in zip(data1, data2)) - sum_data1 * sum_data2\n            denominator = math.sqrt((n * sum_data1_sq - sum_data1 ** 2) * (n * sum_data2_sq - sum_data2 ** 2))\n            if denominator == 0:\n                return 0\n            return numerator / denominator\n        \n        def get_outliers(data):\n            mu = sum(data) / len(data)\n            sigma = math.sqrt(sum((x - mu) ** 2 for x in data) / len(data))\n            outliers = [x for x in data if abs(x - mu) > 2 * sigma]\n            return outliers\n\n        outliers1 = get_outliers(data1)\n        outliers2 = get_outliers(data2)\n\n        filtered_data1 = [x for x in data1 if x not in outliers1]\n        filtered_data2 = [x for x in data2 if x not in outliers2]\n\n        return correlation_coefficient(filtered_data1, filtered_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean_data = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean_data) ** 2 for x in data]) / len(data))\n            outliers_removed = [x for x in data if x >= mean_data - 2 * std_dev and x <= mean_data + 2 * std_dev]\n            return outliers_removed\n        \n        data1_filtered = remove_outliers(data1)\n        data2_filtered = remove_outliers(data2)\n        \n        return DataStatistics4.correlation_coefficient(data1_filtered, data2_filtered)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        clean_data1 = remove_outliers(data1)\n        clean_data2 = remove_outliers(data2)\n\n        return DataStatistics4.correlation_coefficient(clean_data1, clean_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n            outliers = [x for x in data if abs(x - mean) > 2 * std_dev]\n            return [x for x in data if x not in outliers]\n\n        data1_clean = remove_outliers(data1)\n        data2_clean = remove_outliers(data2)\n\n        return DataStatistics4.correlation_coefficient(data1_clean, data2_clean)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def correlation_coefficient(data1, data2):\n            pass\n\n        def remove_outliers(data):\n            pass\n\n        def std_mean(data):\n            pass\n\n        data1_filtered = remove_outliers(data1)\n        data2_filtered = remove_outliers(data2)\n\n        return correlation_coefficient(data1_filtered, data2_filtered)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n            def find_outliers(data):\n                mean = sum(data) / len(data)\n                std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n                outliers = [x for x in data if abs(x - mean) > 2 * std_dev]\n                return outliers\n\n            outliers_data1 = find_outliers(data1)\n            outliers_data2 = find_outliers(data2)\n\n            data1_filtered = [x for x in data1 if x not in outliers_data1 and x not in outliers_data2]\n            data2_filtered = [x for x in data2 if x not in outliers_data1 and x not in outliers_data2]\n\n            correlation = DataStatistics4.correlation_coefficient(data1_filtered, data2_filtered)\n            return correlation",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        data1_mean = sum(data1) / len(data1)\n        data2_mean = sum(data2) / len(data2)\n        \n        data1_std = math.sqrt(sum([(x - data1_mean) ** 2 for x in data1]) / len(data1))\n        data2_std = math.sqrt(sum([(x - data2_mean) ** 2 for x in data2]) / len(data2))\n\n        data1_filtered = [x for x in data1 if abs(x - data1_mean) <= 2 * data1_std]\n        data2_filtered = [x for x in data2 if abs(x - data2_mean) <= 2 * data2_std]\n        \n        return DataStatistics4.correlation_coefficient(data1_filtered, data2_filtered)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outliers(data):\n        mean = sum(data) / len(data)\n        std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n        return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n    data1_without_outliers = remove_outliers(data1)\n    data2_without_outliers = remove_outliers(data2)\n\n    return DataStatistics4.correlation_coefficient(data1_without_outliers, data2_without_outliers)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outliers(data):\n        mean = sum(data) / len(data)\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n        return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n    data1_filtered = remove_outliers(data1)\n    data2_filtered = remove_outliers(data2)\n\n    return DataStatistics4.correlation_coefficient(data1_filtered, data2_filtered)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    mean1 = sum(data1) / len(data1)\n    mean2 = sum(data2) / len(data2)\n    \n    std1 = (sum((x - mean1) ** 2 for x in data1) / len(data1)) ** 0.5\n    std2 = (sum((x - mean2) ** 2 for x in data2) / len(data2)) ** 0.5\n    \n    data1_filtered = [x for x in data1 if abs(x - mean1) <= 2 * std1]\n    data2_filtered = [x for x in data2 if abs(x - mean2) <= 2 * std2]\n    \n    return DataStatistics4.correlation_coefficient(data1_filtered, data2_filtered)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            standard_deviation = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * standard_deviation]\n\n        data1 = remove_outliers(data1)\n        data2 = remove_outliers(data2)\n\n        return DataStatistics4.correlation_coefficient(data1, data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outliers(data):\n        mean_data = sum(data) / len(data)\n        std_dev_data = math.sqrt(sum([(x - mean_data) ** 2 for x in data]) / (len(data) - 1))\n        return [x for x in data if abs(x - mean_data) <= 2 * std_dev_data]\n\n    data1_filtered = remove_outliers(data1)\n    data2_filtered = remove_outliers(data2)\n\n    return DataStatistics4.correlation_coefficient(data1_filtered, data2_filtered)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        filtered_data1 = remove_outliers(data1)\n        filtered_data2 = remove_outliers(data2)\n\n        return DataStatistics4.correlation_coefficient(filtered_data1, filtered_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    mean_data1 = sum(data1) / len(data1)\n    mean_data2 = sum(data2) / len(data2)\n    std_data1 = (sum([(x - mean_data1) ** 2 for x in data1]) / len(data1)) ** 0.5\n    std_data2 = (sum([(x - mean_data2) ** 2 for x in data2]) / len(data2)) ** 0.5\n\n    filtered_data1 = [x for x in data1 if abs(x - mean_data1) <= 2 * std_data1]\n    filtered_data2 = [x for x in data2 if abs(x - mean_data2) <= 2 * std_data2]\n\n    return DataStatistics4.correlation_coefficient(filtered_data1, filtered_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def filter_outliers(data):\n            mean_val = sum(data) / len(data)\n            std_dev = math.sqrt(sum((x - mean_val) ** 2 for x in data) / len(data))\n            filtered_data = [x for x in data if abs(x - mean_val) <= 2 * std_dev]\n            return filtered_data\n\n        filtered_data1 = filter_outliers(data1)\n        filtered_data2 = filter_outliers(data2)\n\n        return DataStatistics4.correlation_coefficient(filtered_data1, filtered_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_deviation = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_deviation]\n\n        filtered_data1 = remove_outliers(data1)\n        filtered_data2 = remove_outliers(data2)\n\n        return DataStatistics4.correlation_coefficient(filtered_data1, filtered_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def correlation_coefficient(data1, data2):\n        pass\n\n    def filter_outliers(data):\n        mean_val = sum(data) / len(data)\n        std_dev = (sum([(x - mean_val) ** 2 for x in data]) / len(data)) ** 0.5\n        filtered_data = [x for x in data if abs(x - mean_val) <= 2 * std_dev]\n        return filtered_data\n\n    filtered_data1 = filter_outliers(data1)\n    filtered_data2 = filter_outliers(data2)\n\n    return correlation_coefficient(filtered_data1, filtered_data2)",
                false
            ]
        ],
        "level 2": [
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = (sum((x - mean) ** 2 for x in data) / len(data)) ** 0.5\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        cleaned_data1 = remove_outliers(data1)\n        cleaned_data2 = remove_outliers(data2)\n\n        if not cleaned_data1 or not cleaned_data2:\n            return 0\n\n        mean_data1 = sum(cleaned_data1) / len(cleaned_data1)\n        mean_data2 = sum(cleaned_data2) / len(cleaned_data2)\n\n        numerator = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(cleaned_data1, cleaned_data2))\n        sum_sq_diff1 = sum((x - mean_data1) ** 2 for x in cleaned_data1)\n        sum_sq_diff2 = sum((y - mean_data2) ** 2 for y in cleaned_data2)\n\n        denominator = (sum_sq_diff1 * sum_sq_diff2) ** 0.5\n\n        if denominator == 0:\n            return 0\n\n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = (sum([(x - mean) ** 2 for x in data]) / len(data)) ** 0.5\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        data1_cleaned = remove_outliers(data1)\n        data2_cleaned = remove_outliers(data2)\n\n        if len(data1_cleaned) == 0 or len(data2_cleaned) == 0:\n            return 0\n\n        mean_data1 = sum(data1_cleaned) / len(data1_cleaned)\n        mean_data2 = sum(data2_cleaned) / len(data2_cleaned)\n\n        numerator = sum([(x1 - mean_data1) * (x2 - mean_data2) for x1, x2 in zip(data1_cleaned, data2_cleaned)])\n        denominator_data1 = sum([(x - mean_data1) ** 2 for x in data1_cleaned]) ** 0.5\n        denominator_data2 = sum([(x - mean_data2) ** 2 for x in data2_cleaned]) ** 0.5\n\n        if denominator_data1 == 0 or denominator_data2 == 0:\n            return 0\n\n        return numerator / (denominator_data1 * denominator_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            sd = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * sd]\n\n        cleaned_data1 = remove_outliers(data1)\n        cleaned_data2 = remove_outliers(data2)\n\n        if len(cleaned_data1) == 0 or len(cleaned_data2) == 0:\n            return 0\n\n        mean_data1 = sum(cleaned_data1) / len(cleaned_data1)\n        mean_data2 = sum(cleaned_data2) / len(cleaned_data2)\n\n        numerator = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(cleaned_data1, cleaned_data2))\n        denominator = math.sqrt(sum((x - mean_data1) ** 2 for x in cleaned_data1) * sum((y - mean_data2) ** 2 for y in cleaned_data2))\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            sd = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * sd]\n        \n        data1_clean = remove_outliers(data1)\n        data2_clean = remove_outliers(data2)\n        \n        if len(data1_clean) == 0 or len(data2_clean) == 0:\n            return 0\n        \n        mean_data1 = sum(data1_clean) / len(data1_clean)\n        mean_data2 = sum(data2_clean) / len(data2_clean)\n        \n        numerator = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(data1_clean, data2_clean))\n        denom_data1 = math.sqrt(sum((x - mean_data1) ** 2 for x in data1_clean))\n        denom_data2 = math.sqrt(sum((y - mean_data2) ** 2 for y in data2_clean))\n        \n        if denom_data1 == 0 or denom_data2 == 0:\n            return 0\n        \n        correlation = numerator / (denom_data1 * denom_data2)\n        return correlation",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = (sum([(x - mean) ** 2 for x in data]) / len(data)) ** 0.5\n            data_cleaned = [x for x in data if abs(x - mean) <= 2 * std_dev]\n            return data_cleaned\n        \n        data1_cleaned = remove_outliers(data1)\n        data2_cleaned = remove_outliers(data2)\n        \n        if len(data1_cleaned) == 0 or len(data2_cleaned) == 0:\n            return 0\n        \n        mean_data1 = sum(data1_cleaned) / len(data1_cleaned)\n        mean_data2 = sum(data2_cleaned) / len(data2_cleaned)\n        \n        numerator = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(data1_cleaned, data2_cleaned))\n        denominator = (sum((x - mean_data1) ** 2 for x in data1_cleaned) * sum((y - mean_data2) ** 2 for y in data2_cleaned)) ** 0.5\n        \n        if denominator == 0:\n            return 0\n        \n        correlation_coefficient = numerator / denominator\n        return float(correlation_coefficient)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outliers(data):\n        mean = sum(data) / len(data)\n        std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n        return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n    data1 = remove_outliers(data1)\n    data2 = remove_outliers(data2)\n\n    if not data1 or not data2:\n        return 0\n\n    mean_data1 = sum(data1) / len(data1)\n    mean_data2 = sum(data2) / len(data2)\n\n    numerator = sum([(data1[i] - mean_data1) * (data2[i] - mean_data2) for i in range(len(data1))])\n    denominator = math.sqrt(sum([(x - mean_data1) ** 2 for x in data1]) * sum([(x - mean_data2) ** 2 for x in data2]))\n\n    if denominator == 0:\n        return 0\n\n    return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def find_outliers(data):\n            mean = sum(data) / len(data)\n            standard_deviation = (sum([(x - mean) ** 2 for x in data]) / len(data)) ** 0.5\n            return [x for x in data if abs(x - mean) <= 2 * standard_deviation]\n\n        data1_no_outliers = find_outliers(data1)\n        data2_no_outliers = find_outliers(data2)\n\n        if not data1_no_outliers or not data2_no_outliers:\n            return 0\n\n        mean_data1 = sum(data1_no_outliers) / len(data1_no_outliers)\n        mean_data2 = sum(data2_no_outliers) / len(data2_no_outliers)\n\n        numerator = sum([(x - mean_data1) * (y - mean_data2) for x, y in zip(data1_no_outliers, data2_no_outliers)])\n        denominator = (sum([(x - mean_data1) ** 2 for x in data1_no_outliers]) * sum([(y - mean_data2) ** 2 for y in data2_no_outliers])) ** 0.5\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean_val = sum(data) / len(data)\n            std_dev = (sum([(x - mean_val) ** 2 for x in data]) / len(data)) ** 0.5\n            outliers = [x for x in data if abs(x - mean_val) > 2 * std_dev]\n            return [x for x in data if x not in outliers]\n\n        data1 = remove_outliers(data1)\n        data2 = remove_outliers(data2)\n\n        if len(data1) == 0 or len(data2) == 0:\n            return 0\n\n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n\n        numerator = sum([(data1[i] - mean_data1) * (data2[i] - mean_data2) for i in range(len(data1))])\n        denominator = (sum([(data1[i] - mean_data1) ** 2 for i in range(len(data1)]) ** 0.5) *\n                       sum([(data2[i] - mean_data2) ** 2 for i in range(len(data2)]) ** 0.5)\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        outliers_removed_data1 = [x for x in data1 if abs(x - sum(data1) / len(data1)) <= 2 * math.sqrt(sum((x - sum(data1) / len(data1)) ** 2 for x in data1) / len(data1))]\n        outliers_removed_data2 = [x for x in data2 if abs(x - sum(data2) / len(data2)) <= 2 * math.sqrt(sum((x - sum(data2) / len(data2)) ** 2 for x in data2) / len(data2)]\n        \n        if not outliers_removed_data1 or not outliers_removed_data2:\n            return 0\n        \n        mean_data1 = sum(outliers_removed_data1) / len(outliers_removed_data1)\n        mean_data2 = sum(outliers_removed_data2) / len(outliers_removed_data2)\n        \n        num = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(outliers_removed_data1, outliers_removed_data2))\n        den = math.sqrt(sum((x - mean_data1) ** 2 for x in outliers_removed_data1) * sum((y - mean_data2) ** 2 for y in outliers_removed_data2))\n        \n        if den == 0:\n            return 0\n        \n        return num / den\n\n",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean_data = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean_data) ** 2 for x in data]) / len(data))\n            return [x for x in data if abs(x - mean_data) <= 2 * std_dev]\n\n        data1_no_outliers = remove_outliers(data1)\n        data2_no_outliers = remove_outliers(data2)\n\n        if len(data1_no_outliers) == 0 or len(data2_no_outliers) == 0:\n            return 0\n\n        mean_data1 = sum(data1_no_outliers) / len(data1_no_outliers)\n        mean_data2 = sum(data2_no_outliers) / len(data2_no_outliers)\n\n        numerator = sum([(x - mean_data1) * (y - mean_data2) for x, y in zip(data1_no_outliers, data2_no_outliers)])\n        denom1 = sum([(x - mean_data1) ** 2 for x in data1_no_outliers])\n        denom2 = sum([(y - mean_data2) ** 2 for y in data2_no_outliers])\n\n        denominator = math.sqrt(denom1 * denom2)\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            standard_deviation = (sum([(x - mean) ** 2 for x in data]) / len(data)) ** 0.5\n            return [x for x in data if abs(x - mean) <= 2 * standard_deviation]\n\n        data1 = remove_outliers(data1)\n        data2 = remove_outliers(data2)\n\n        if not data1 or not data2:\n            return 0\n\n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n\n        numerator = sum([(data1[i] - mean_data1) * (data2[i] - mean_data2) for i in range(len(data1))])\n        denominator_data1 = sum([(x - mean_data1) ** 2 for x in data1]) ** 0.5\n        denominator_data2 = sum([(x - mean_data2) ** 2 for x in data2]) ** 0.5\n\n        if denominator_data1 == 0 or denominator_data2 == 0:\n            return 0\n\n        return numerator / (denominator_data1 * denominator_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        clean_data1 = remove_outliers(data1)\n        clean_data2 = remove_outliers(data2)\n\n        if len(clean_data1) == 0 or len(clean_data2) == 0:\n            return 0.0\n\n        mean_data1 = sum(clean_data1) / len(clean_data1)\n        mean_data2 = sum(clean_data2) / len(clean_data2)\n\n        numerator = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(clean_data1, clean_data2))\n        denominator = math.sqrt(sum((x - mean_data1) ** 2 for x in clean_data1) * sum((y - mean_data2) ** 2 for y in clean_data2))\n\n        if denominator == 0:\n            return 0.0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean_val = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean_val) ** 2 for x in data]) / len(data))\n            outliers = [x for x in data if abs(x - mean_val) > 2 * std_dev]\n            return [x for x in data if x not in outliers]\n\n        def correlation_coefficient(data1, data2):\n            mean1 = sum(data1) / len(data1)\n            mean2 = sum(data2) / len(data2)\n\n            numerator = sum([(x1 - mean1) * (x2 - mean2) for x1, x2 in zip(data1, data2)])\n            denominator = math.sqrt(sum([(x1 - mean1) ** 2 for x1 in data1]) * sum([(x2 - mean2) ** 2 for x2 in data2]))\n            \n            if denominator == 0:\n                return 0\n            else:\n                return numerator / denominator\n\n        data1_filtered = remove_outliers(data1)\n        data2_filtered = remove_outliers(data2)\n\n        return correlation_coefficient(data1_filtered, data2_filtered)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = (sum((x - mean) ** 2 for x in data) / len(data)) ** 0.5\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        data1 = remove_outliers(data1)\n        data2 = remove_outliers(data2)\n\n        if not data1 or not data2:\n            return 0\n\n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n\n        numerator = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(data1, data2))\n        denominator = (sum((x - mean_data1) ** 2 for x in data1) * sum((y - mean_data2) ** 2 for y in data2)) ** 0.5\n\n        if denominator == 0:\n            return 0\n\n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def filter_outliers(data):\n        mean = sum(data) / len(data)\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n        return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n    filtered_data1 = filter_outliers(data1)\n    filtered_data2 = filter_outliers(data2)\n\n    if not filtered_data1 or not filtered_data2:\n        return 0\n\n    mean_data1 = sum(filtered_data1) / len(filtered_data1)\n    mean_data2 = sum(filtered_data2) / len(filtered_data2)\n\n    numer = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(filtered_data1, filtered_data2))\n    denom1 = math.sqrt(sum((x - mean_data1) ** 2 for x in filtered_data1))\n    denom2 = math.sqrt(sum((y - mean_data2) ** 2 for y in filtered_data2))\n\n    if denom1 == 0 or denom2 == 0:\n        return 0\n    else:\n        return numer / (denom1 * denom2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def eliminate_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        data1 = eliminate_outliers(data1)\n        data2 = eliminate_outliers(data2)\n\n        if not data1 or not data2:\n            return 0\n\n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n\n        numerator = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(data1, data2))\n        denominator_data1 = math.sqrt(sum((x - mean_data1) ** 2 for x in data1))\n        denominator_data2 = math.sqrt(sum((y - mean_data2) ** 2 for y in data2)\n\n        if denominator_data1 == 0 or denominator_data2 == 0:\n            return 0\n        else:\n            return numerator / (denominator_data1 * denominator_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def eliminate_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        data1_no_outliers = eliminate_outliers(data1)\n        data2_no_outliers = eliminate_outliers(data2)\n\n        if len(data1_no_outliers) == 0 or len(data2_no_outliers) == 0:\n            return 0\n\n        mean_data1 = sum(data1_no_outliers) / len(data1_no_outliers)\n        mean_data2 = sum(data2_no_outliers) / len(data2_no_outliers)\n\n        numerator = sum([(x - mean_data1) * (y - mean_data2) for x, y in zip(data1_no_outliers, data2_no_outliers)])\n        denominator = math.sqrt(sum([(x - mean_data1) ** 2 for x in data1_no_outliers]) * sum([(y - mean_data2) ** 2 for y in data2_no_outliers]))\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean_val = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean_val) ** 2 for x in data]) / len(data))\n            return [x for x in data if abs(x - mean_val) <= 2 * std_dev]\n\n        def correlation_coefficient(data1, data2):\n            mean_data1 = sum(data1) / len(data1)\n            mean_data2 = sum(data2) / len(data2)\n            numerator = sum([(data1[i] - mean_data1) * (data2[i] - mean_data2) for i in range(len(data1))])\n            denominator = math.sqrt(sum([(data1[i] - mean_data1) ** 2 for i in range(len(data1)]) * sum([(data2[i] - mean_data2) ** 2 for i in range(len(data2)]))\n            if denominator == 0:\n                return 0\n            return numerator / denominator\n\n        data1_no_outliers = remove_outliers(data1)\n        data2_no_outliers = remove_outliers(data2)\n\n        return correlation_coefficient(data1_no_outliers, data2_no_outliers)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n        \n        data1 = remove_outliers(data1)\n        data2 = remove_outliers(data2)\n        \n        if len(data1) == 0 or len(data2) == 0:\n            return 0\n        \n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n        \n        numerator = sum([(x - mean_data1) * (y - mean_data2) for x, y in zip(data1, data2)])\n        denominator = math.sqrt(sum([(x - mean_data1) ** 2 for x in data1]) * sum([(y - mean_data2) ** 2 for y in data2]))\n        \n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outliers(data):\n        mean = sum(data) / len(data)\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n        return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n    data1_no_outliers = remove_outliers(data1)\n    data2_no_outliers = remove_outliers(data2)\n\n    if len(data1_no_outliers) == 0 or len(data2_no_outliers) == 0:\n        return 0\n\n    mean_data1 = sum(data1_no_outliers) / len(data1_no_outliers)\n    mean_data2 = sum(data2_no_outliers) / len(data2_no_outliers)\n\n    numerator = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(data1_no_outliers, data2_no_outliers))\n    \n    sum_sqrs_data1 = sum((x - mean_data1) ** 2 for x in data1_no_outliers)\n    sum_sqrs_data2 = sum((y - mean_data2) ** 2 for y in data2_no_outliers)\n    \n    denominator = math.sqrt(sum_sqrs_data1 * sum_sqrs_data2)\n\n    if denominator == 0:\n        return 0\n    else:\n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        data1 = remove_outliers(data1)\n        data2 = remove_outliers(data2)\n\n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n\n        numerator = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(data1, data2))\n        denominator = math.sqrt(sum((x - mean_data1) ** 2 for x in data1) * sum((y - mean_data2) ** 2 for y in data2))\n\n        if denominator == 0:\n            return 0.0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        data1 = remove_outliers(data1)\n        data2 = remove_outliers(data2)\n\n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n\n        numerator = sum([(data1[i] - mean_data1) * (data2[i] - mean_data2) for i in range(len(data1))])\n        denominator = math.sqrt(sum([(data1[i] - mean_data1) ** 2 for i in range(len(data1)]) * sum([(data2[i] - mean_data2) ** 2 for i in range(len(data2)]))\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        data1 = remove_outliers(data1)\n        data2 = remove_outliers(data2)\n\n        if len(data1) == 0 or len(data2) == 0:\n            return 0\n\n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n\n        numerator = sum((data1[i] - mean_data1) * (data2[i] - mean_data2) for i in range(len(data1)))\n        denominator_data1 = math.sqrt(sum((x - mean_data1) ** 2 for x in data1))\n        denominator_data2 = math.sqrt(sum((x - mean_data2) ** 2 for x in data2)\n\n        if denominator_data1 == 0 or denominator_data2 == 0:\n            return 0\n\n        return numerator / (denominator_data1 * denominator_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = (sum([(x - mean) ** 2 for x in data]) / len(data)) ** 0.5\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        data1 = remove_outliers(data1)\n        data2 = remove_outliers(data2)\n\n        def correlation_coefficient(data1, data2):\n            mean1 = sum(data1) / len(data1)\n            mean2 = sum(data2) / len(data2)\n\n            numerator = sum([(x - mean1) * (y - mean2) for x, y in zip(data1, data2)])\n            denominator = math.sqrt(sum([(x - mean1) ** 2 for x in data1]) * sum([(y - mean2) ** 2 for y in data2]))\n\n            if denominator == 0:\n                return 0\n            else:\n                return numerator / denominator\n\n        return correlation_coefficient(data1, data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / len(data))\n            return [x for x in data if abs(x - mean) <= 2 * std_dev]\n\n        data1 = remove_outliers(data1)\n        data2 = remove_outliers(data2)\n\n        if len(data1) == 0 or len(data2) == 0:\n            return 0\n\n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n\n        numerator = sum([(data1[i] - mean_data1) * (data2[i] - mean_data2) for i in range(len(data1))])\n        denominator = math.sqrt(sum([(x - mean_data1) ** 2 for x in data1]) * sum([(x - mean_data2) ** 2 for x in data2]))\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean_val = sum(data) / len(data)\n            std_dev = math.sqrt(sum((x - mean_val) ** 2 for x in data) / len(data))\n            return [x for x in data if abs(x - mean_val) <= 2 * std_dev]\n\n        data1_clean = remove_outliers(data1)\n        data2_clean = remove_outliers(data2)\n\n        if len(data1_clean) == 0 or len(data2_clean) == 0:\n            return 0\n\n        mean_data1 = sum(data1_clean) / len(data1_clean)\n        mean_data2 = sum(data2_clean) / len(data2_clean)\n\n        numerator = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(data1_clean, data2_clean))\n        denominator_data1 = sum((x - mean_data1) ** 2 for x in data1_clean)\n        denominator_data2 = sum((y - mean_data2) ** 2 for y in data2_clean)\n\n        if denominator_data1 == 0 or denominator_data2 == 0:\n            return 0\n\n        denominator = math.sqrt(denominator_data1 * denominator_data2)\n\n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            mean_val = sum(data) / len(data)\n            std_dev = (sum((x - mean_val) ** 2 for x in data) / len(data)) ** 0.5\n            outliers = [x for x in data if abs(x - mean_val) > 2 * std_dev]\n            return [x for x in data if x not in outliers]\n\n        data1_cleaned = remove_outliers(data1)\n        data2_cleaned = remove_outliers(data2)\n\n        if len(data1_cleaned) == 0 or len(data2_cleaned) == 0:\n            return 0\n\n        mean_data1 = sum(data1_cleaned) / len(data1_cleaned)\n        mean_data2 = sum(data2_cleaned) / len(data2_cleaned)\n\n        correlation_numerator = sum((x - mean_data1) * (y - mean_data2) for x, y in zip(data1_cleaned, data2_cleaned))\n\n        correlation_denominator_data1 = sum((x - mean_data1) ** 2 for x in data1_cleaned) ** 0.5\n        correlation_denominator_data2 = sum((y - mean_data2) ** 2 for y in data2_cleaned) ** 0.5\n\n        if correlation_denominator_data1 == 0 or correlation_denominator_data2 == 0:\n            return 0\n\n        return correlation_numerator / (correlation_denominator_data1 * correlation_denominator_data2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def find_outliers(data):\n            mean_val = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean_val) ** 2 for x in data]) / len(data))\n            outliers = [x for x in data if abs(x - mean_val) > 2 * std_dev]\n            return outliers\n        \n        outliers1 = find_outliers(data1)\n        outliers2 = find_outliers(data2)\n        \n        clean_data1 = [x for x in data1 if x not in outliers1]\n        clean_data2 = [x for x in data2 if x not in outliers2]\n        \n        if len(clean_data1) == 0 or len(clean_data2) == 0:\n            return 0\n        \n        mean1 = sum(clean_data1) / len(clean_data1)\n        mean2 = sum(clean_data2) / len(clean_data2)\n        \n        numerator = sum([(x - mean1) * (y - mean2) for x, y in zip(clean_data1, clean_data2)])\n        denominator = math.sqrt(sum([(x - mean1) ** 2 for x in clean_data1]) * sum([(y - mean2) ** 2 for y in clean_data2]))\n        \n        if denominator == 0:\n            return 0\n        \n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def find_outliers(data):\n            mean_data = sum(data) / len(data)\n            std_dev = (sum([(x - mean_data) ** 2 for x in data]) / len(data)) ** 0.5\n            outliers = [x for x in data if abs(x - mean_data) > 2 * std_dev]\n            return outliers\n\n        outliers_data1 = find_outliers(data1)\n        outliers_data2 = find_outliers(data2)\n\n        cleaned_data1 = [x for x in data1 if x not in outliers_data1]\n        cleaned_data2 = [x for x in data2 if x not in outliers_data2]\n\n        if len(cleaned_data1) == 0:\n            return 0\n        \n        mean_data1 = sum(cleaned_data1) / len(cleaned_data1)\n        mean_data2 = sum(cleaned_data2) / len(cleaned_data2)\n\n        num = sum([(x - mean_data1) * (y - mean_data2) for x, y in zip(cleaned_data1, cleaned_data2)])\n        den = (sum([(x - mean_data1) ** 2 for x in cleaned_data1]) * sum([(y - mean_data2) ** 2 for y in cleaned_data2])) ** 0.5\n\n        if den == 0:\n            return 0\n        \n        return num / den",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def find_outliers(data):\n        outliers = []\n        mean_val = sum(data) / len(data)\n        std_dev = (sum([(x - mean_val) ** 2 for x in data]) / len(data)) ** 0.5\n        for val in data:\n            if abs(val - mean_val) > 2 * std_dev:\n                outliers.append(val)\n        return outliers\n\n    outliers1 = find_outliers(data1)\n    outliers2 = find_outliers(data2)\n\n    data1_clean = [x for x in data1 if x not in outliers1]\n    data2_clean = [x for x in data2 if x not in outliers2]\n\n    if not data1_clean or not data2_clean:\n        return 0\n\n    mean_data1 = sum(data1_clean) / len(data1_clean)\n    mean_data2 = sum(data2_clean) / len(data2_clean)\n\n    num = sum([(data1_clean[i] - mean_data1) * (data2_clean[i] - mean_data2) for i in range(len(data1_clean))])\n    den = (sum([(x - mean_data1) ** 2 for x in data1_clean]) * sum([(y - mean_data2) ** 2 for y in data2_clean])) ** 0.5\n\n    if den == 0:\n        return 0\n    else:\n        return num / den",
                false
            ]
        ],
        "level 3": [
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outliers = [i for i in range(len(data) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            return outliers\n        \n        outliers1 = remove_outlier(data1)\n        outliers2 = remove_outlier(data2)\n        \n        data1_clean = [data1[i] for i in range(len(data1)) if i not in outliers1 and i not in outliers2]\n        data2_clean = [data2[i] for i in range(len(data2)) if i not in outliers1 and i not in outliers2]\n        \n        mean1 = sum(data1_clean) / len(data1_clean)\n        mean2 = sum(data2_clean) / len(data2_clean)\n        \n        numerator = sum([(data1_clean[i] - mean1) * (data2_clean[i] - mean2) for i in range(len(data1_clean))])\n        std1 = math.sqrt(sum([(x - mean1) ** 2 for x in data1_clean]) / len(data1_clean)\n        std2 = math.sqrt(sum([(x - mean2) ** 2 for x in data2_clean]) / len(data2_clean)\n        \n        if std1 != 0 and std2 != 0:\n            return numerator / (std1 * std2)\n        else:\n            return 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            return [i for i in range(len(data)) if data[i] < data_mean + 2 * data_std]\n\n        outliers1 = remove_outlier(data1)\n        outliers2 = remove_outlier(data2)\n\n        data1_cleaned = [data1[i] for i in range(len(data1)) if i not in outliers1 and i not in outliers2]\n        data2_cleaned = [data2[i] for i in range(len(data2)) if i not in outliers1 and i not in outliers2]\n\n        mean1 = sum(data1_cleaned) / len(data1_cleaned)\n        mean2 = sum(data2_cleaned) / len(data2_cleaned)\n\n        num = sum([(data1_cleaned[i] - mean1) * (data2_cleaned[i] - mean2) for i in range(len(data1_cleaned))])\n        den = math.sqrt(sum([(x - mean1) ** 2 for x in data1_cleaned]) * sum([(x - mean2) ** 2 for x in data2_cleaned]))\n\n        return num / den if den != 0 else 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outliers = [i for i in range(len(data) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            cleaned_data = [data[i] for i in range(len(data)) if i not in outliers]\n            return cleaned_data, sum(cleaned_data) / len(cleaned_data), math.sqrt(sum([(x - data_mean) ** 2 for x in cleaned_data]) / len(cleaned_data)\n\n        data1_cleaned, mean1, std1 = remove_outlier(data1)\n        data2_cleaned, mean2, std2 = remove_outlier(data2)\n\n        numerator = sum([(data1_cleaned[i] - mean1) * (data2_cleaned[i] - mean2) for i in range(len(data1_cleaned))])\n        denominator = std1 * std2\n\n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n    def remove_outlier(data):\n        data_mean = sum(data) / len(data)\n        data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n        outlier_indices = [i for i in range(len(data)) if data[i] > data_mean + 2 * data_std]\n        return [data[i] for i in range(len(data)) if i not in outlier_indices]\n\n    data1 = remove_outlier(data1)\n    data2 = remove_outlier(data2)\n\n    if len(data1) == 0 or len(data2) == 0:\n        return 0\n\n    mean1 = sum(data1) / len(data1)\n    mean2 = sum(data2) / len(data2)\n\n    numerator = sum([(data1[i] - mean1) * (data2[i] - mean2) for i in range(len(data1))])\n    denominator = math.sqrt(sum([(x - mean1) ** 2 for x in data1]) * sum([(x - mean2) ** 2 for x in data2]))\n\n    if denominator == 0:\n        return 0\n\n    return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outliers = [i for i in range(len(data)) if data[i] > data_mean + 2 * data_std]\n            return [data[i] for i in range(len(data)) if i not in outliers]\n\n        data1_clean = remove_outlier(data1)\n        data2_clean = remove_outlier(data2)\n\n        mean1 = sum(data1_clean) / len(data1_clean)\n        mean2 = sum(data2_clean) / len(data2_clean)\n\n        numerator = sum([(data1_clean[i] - mean1) * (data2_clean[i] - mean2) for i in range(len(data1_clean)])\n        denominator = math.sqrt(sum([(x - mean1) ** 2 for x in data1_clean]) * sum([(x - mean2) ** 2 for x in data2_clean])\n\n        if denominator != 0:\n            return numerator / denominator\n        else:\n            return 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        data1_mean, data1_std = remove_outlier(data1)\n        data2_mean, data2_std = remove_outlier(data2)\n\n        data1_outliers = [i for i in range(len(data1)) if data1[i] < data1_mean + 2 * data1_std]\n        data2_outliers = [i for i in range(len(data2)) if data2[i] < data2_mean + 2 * data2_std]\n\n        outliers = list(set(data1_outliers) | set(data2_outliers))\n        \n        data1 = [data1[i] for i in range(len(data1)) if i not in outliers]\n        data2 = [data2[i] for i in range(len(data2)) if i not in outliers]\n\n        mean1 = sum(data1) / len(data1)\n        mean2 = sum(data2) / len(data2)\n\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(len(data1)))\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(len(data1))) * sum((data2[i] - mean2) ** 2 for i in range(len(data2)))\n\n        return numerator / denominator if denominator != 0 else 0\n\n",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            return [x for x in data if x > data_mean - 2 * data_std and x < data_mean + 2 * data_std]\n        \n        data1 = remove_outlier(data1)\n        data2 = remove_outlier(data2)\n        \n        common_indices = [i for i in range(len(data1)) if i < len(data2) and i in [j for j in range(len(data2))]]\n        data1 = [data1[i] for i in common_indices]\n        data2 = [data2[i] for i in common_indices]\n        \n        mean1 = sum(data1) / len(data1)\n        mean2 = sum(data2) / len(data2)\n        \n        numerator = sum([(data1[i] - mean1) * (data2[i] - mean2) for i in range(len(data1))])\n        denominator = math.sqrt(sum([(data1[i] - mean1) ** 2 for i in range(len(data1)]) * sum([(data2[i] - mean2) ** 2 for i in range(len(data2)])))\n        \n        if denominator != 0:\n            return numerator / denominator\n        else:\n            return 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            return [x for x in data if x >= data_mean - 2 * data_std and x <= data_mean + 2 * data_std]\n\n        clean_data1 = remove_outlier(data1)\n        clean_data2 = remove_outlier(data2)\n\n        common_indices = set([i for i in range(len(data1)) if i in [j for j in range(len(data2))]])\n\n        data1 = [data1[i] for i in common_indices]\n        data2 = [data2[i] for i in common_indices]\n\n        mean1 = sum(data1) / len(data1)\n        mean2 = sum(data2) / len(data2)\n\n        numerator = sum([(data1[i] - mean1) * (data2[i] - mean2) for i in range(len(data1))])\n        denominator = math.sqrt(sum([(data1[i] - mean1) ** 2 for i in range(len(data1)]) * sum([(data2[i] - mean2) ** 2 for i in range(len(data2)]))\n\n        if denominator != 0:\n            return numerator / denominator\n        else:\n            return 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        data1_mean = remove_outlier(data1)[0]\n        data1_std = remove_outlier(data1)[1]\n        data2_mean = remove_outlier(data2)[0]\n        data2_std = remove_outlier(data2)[1]\n\n        data1_clean = [data1[i] for i in range(len(data1)) if data1[i] < data1_mean + 2 * data1_std]\n        data2_clean = [data2[i] for i in range(len(data2)) if data2[i] < data2_mean + 2 * data2_std]\n\n        data_clean_indices = list(set([i for i in range(len(data1)) if data1[i] in data1_clean]).intersection(\n            [i for i in range(len(data2)) if data2[i] in data2_clean]))\n\n        data1_clean = [data1[i] for i in data_clean_indices]\n        data2_clean = [data2[i] for i in data_clean_indices]\n\n        mean1 = sum(data1_clean) / len(data1_clean)\n        mean2 = sum(data2_clean) / len(data2_clean)\n\n        numerator = sum((data1_clean[i] - mean1) * (data2_clean[i] - mean2) for i in range(len(data1_clean)))\n        denominator = math.sqrt(sum((data1_clean[i] - mean1) ** 2 for i in range(len(data1_clean))) * sum(\n            (data2_clean[i] - mean2) ** 2 for i in range(len(data2_clean)))\n\n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            mean = sum(data) / len(data)\n            std_dev = math.sqrt(sum([(x - mean) ** 2 for x in data]) / (len(data) - 1))\n            return [x for x in data if x >= mean - 2 * std_dev and x <= mean + 2 * std_dev], mean, std_dev\n\n        data1, mean1, std_dev1 = remove_outlier(data1)\n        data2, mean2, std_dev2 = remove_outlier(data2)\n\n        common_indices = set([i for i in range(len(data1)) if i in [j for j in range(len(data2))]])\n\n        data1 = [data1[i] for i in common_indices]\n        data2 = [data2[i] for i in common_indices]\n\n        numerator = sum([(data1[i] - mean1) * (data2[i] - mean2) for i in range(len(data1)])\n        denominator = std_dev1 * std_dev2\n\n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outliers_indices = [i for i in range(len(data)) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            return [data[i] for i in range(len(data)) if i not in outliers_indices]\n\n        data1 = remove_outlier(data1)\n        data2 = remove_outlier(data2)\n\n        if len(data1) != len(data2) or len(data1) == 0:\n            return 0\n\n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n\n        numerator = sum([(data1[i] - mean_data1) * (data2[i] - mean_data2) for i in range(len(data1))])\n        denominator = math.sqrt(sum([(data1[i] - mean_data1) ** 2 for i in range(len(data1)]) * sum([(data2[i] - mean_data2) ** 2 for i in range(len(data2)]))\n\n        if denominator == 0:\n            return 0\n\n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outliers_indices = [i for i in range(len(data)) if data[i] > data_mean + 2 * data_std or data[i] < data_mean - 2 * data_std]\n            return [val for idx, val in enumerate(data) if idx not in outliers_indices]\n\n        data1_clean = remove_outlier(data1)\n        data2_clean = remove_outlier(data2)\n\n        if len(data1_clean) != len(data2_clean) or len(data1_clean) == 0:\n            return 0\n        \n        data1_mean = sum(data1_clean) / len(data1_clean)\n        data2_mean = sum(data2_clean) / len(data2_clean)\n        \n        numerator = sum([(data1_clean[i] - data1_mean) * (data2_clean[i] - data2_mean) for i in range(len(data1_clean))])\n        denominator = math.sqrt(sum([(data1_clean[i] - data1_mean) ** 2 for i in range(len(data1_clean)]) * sum([(data2_clean[i] - data2_mean) ** 2 for i in range(len(data2_clean)]))\n        \n        if denominator == 0:\n            return 0\n        else:\n            return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outlier_indices = [i for i in range(len(data)) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            data_cleaned = [x for i, x in enumerate(data) if i not in outlier_indices]\n            return data_cleaned, data_mean\n        \n        data1_cleaned, data1_mean = remove_outlier(data1)\n        data2_cleaned, data2_mean = remove_outlier(data2)\n        \n        if len(data1_cleaned) == 0 or len(data2_cleaned) == 0:\n            return 0\n        \n        numerator = sum([(data1_cleaned[i] - data1_mean) * (data2_cleaned[i] - data2_mean) for i in range(len(data1_cleaned))])\n        denominator = math.sqrt(sum([(data1_cleaned[i] - data1_mean) ** 2 for i in range(len(data1_cleaned)])) * math.sqrt(sum([(data2_cleaned[i] - data2_mean) ** 2 for i in range(len(data2_cleaned)]))\n        \n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outliers = [i for i in range(len(data)) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            return [data[i] for i in range(len(data)) if i not in outliers]\n\n        data1 = remove_outlier(data1)\n        data2 = remove_outlier(data2)\n\n        if len(data1) != len(data2) or len(data1) < 2:\n            return 0\n\n        mean_data1 = sum(data1) / len(data1)\n        mean_data2 = sum(data2) / len(data2)\n\n        numerator = sum([(data1[i] - mean_data1) * (data2[i] - mean_data2) for i in range(len(data1))])\n        denom_data1 = math.sqrt(sum([(x - mean_data1) ** 2 for x in data1]))\n        denom_data2 = math.sqrt(sum([(x - mean_data2) ** 2 for x in data2])\n\n        correlation_coefficient = numerator / (denom_data1 * denom_data2)\n        return correlation_coefficient if denom_data1 != 0 and denom_data2 != 0 else 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outliers_indices = [i for i in range(len(data)) if data[i] > data_mean + 2 * data_std or data[i] < data_mean - 2 * data_std]\n            return [data[i] for i in range(len(data)) if i not in outliers_indices]\n\n        data1_clean = remove_outlier(data1)\n        data2_clean = remove_outlier(data2)\n\n        if len(data1_clean) == 0 or len(data2_clean) == 0:\n            return 0\n\n        mean_data1 = sum(data1_clean) / len(data1_clean)\n        mean_data2 = sum(data2_clean) / len(data2_clean)\n\n        numerator = sum([(data1_clean[i] - mean_data1) * (data2_clean[i] - mean_data2) for i in range(len(data1_clean))])\n        denominator = math.sqrt(sum([(data1_clean[i] - mean_data1) ** 2 for i in range(len(data1_clean)]) * sum([(data2_clean[i] - mean_data2) ** 2 for i in range(len(data2_clean)]))\n\n        if denominator == 0:\n            return 0\n\n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / (len(data) - 1))\n            outliers = [i for i in range(len(data)) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            cleaned_data = [x for i, x in enumerate(data) if i not in outliers]\n            return cleaned_data, sum(cleaned_data) / len(cleaned_data), math.sqrt(sum([(x - sum(cleaned_data) / len(cleaned_data)) ** 2 for x in cleaned_data]) / (len(cleaned_data) - 1)\n        \n        cleaned_data1, mean1, std1 = remove_outlier(data1)\n        cleaned_data2, mean2, std2 = remove_outlier(data2)\n        \n        if len(cleaned_data1) == 0 or len(cleaned_data2) == 0:\n            return 0\n        \n        numerator = sum([(data1[i] - mean1) * (data2[i] - mean2) for i in range(len(cleaned_data1))])\n        denominator = math.sqrt(sum([(x - mean1) ** 2 for x in cleaned_data1]) * sum([(x - mean2) ** 2 for x in cleaned_data2]))\n        \n        if denominator == 0:\n            return 0\n        \n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outliers = [i for i in range(len(data)) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            return [data[i] for i in range(len(data)) if i not in outliers]\n\n        cleaned_data1 = remove_outlier(data1)\n        cleaned_data2 = remove_outlier(data2)\n\n        mean1 = sum(cleaned_data1) / len(cleaned_data1)\n        mean2 = sum(cleaned_data2) / len(cleaned_data2)\n\n        numerator = sum((x - mean1) * (y - mean2) for x, y in zip(cleaned_data1, cleaned_data2))\n        denom1 = sum((x - mean1) ** 2 for x in cleaned_data1)\n        denom2 = sum((y - mean2) ** 2 for y in cleaned_data2)\n\n        if denom1 == 0 or denom2 == 0:\n            return 0\n        else:\n            return numerator / math.sqrt(denom1 * denom2)",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outliers = [i for i in range(len(data)) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            return [x for i, x in enumerate(data) if i not in outliers]\n        \n        data1_cleaned = remove_outlier(data1)\n        data2_cleaned = remove_outlier(data2)\n        \n        mean1 = sum(data1_cleaned) / len(data1_cleaned)\n        mean2 = sum(data2_cleaned) / len(data2_cleaned)\n        \n        numerator = sum([(data1_cleaned[i] - mean1) * (data2_cleaned[i] - mean2) for i in range(len(data1_cleaned))])\n        denominator = math.sqrt(sum([(x - mean1) ** 2 for x in data1_cleaned]) * sum([(x - mean2) ** 2 for x in data2_cleaned]))\n        \n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outliers = [i for i in range(len(data)) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            return [data[i] for i in range(len(data)) if i not in outliers]\n\n        data1_cleaned = remove_outlier(data1)\n        data2_cleaned = remove_outlier(data2)\n        \n        mean1 = sum(data1_cleaned) / len(data1_cleaned)\n        mean2 = sum(data2_cleaned) / len(data2_cleaned)\n        \n        numerator = sum([(data1_cleaned[i] - mean1) * (data2_cleaned[i] - mean2) for i in range(len(data1_cleaned))])\n        denominator = math.sqrt(sum([(x - mean1) ** 2 for x in data1_cleaned]) * sum([(x - mean2) ** 2 for x in data2_cleaned]))\n\n        if denominator != 0:\n            correlation_coefficient = numerator / denominator\n        else:\n            correlation_coefficient = 0\n        \n        return correlation_coefficient",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outlier_indices = [i for i in range(len(data)) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            return [data[i] for i in range(len(data)) if i not in outlier_indices]\n\n        clean_data1 = remove_outlier(data1)\n        clean_data2 = remove_outlier(data2)\n\n        mean1 = sum(clean_data1) / len(clean_data1)\n        mean2 = sum(clean_data2) / len(clean_data2)\n\n        numerator = sum((x - mean1) * (y - mean2) for x, y in zip(clean_data1, clean_data2))\n        denominator = math.sqrt(sum((x - mean1) ** 2 for x in clean_data1) * sum((y - mean2) ** 2 for y in clean_data2))\n\n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / (len(data) - 1))\n            outlier_indices = [i for i in range(len(data)) if data[i] > data_mean + 2 * data_std or data[i] < data_mean - 2 * data_std]\n            return [x for i, x in enumerate(data) if i not in outlier_indices]\n\n        data1_filtered = remove_outlier(data1)\n        data2_filtered = remove_outlier(data2)\n\n        if len(data1_filtered) == 0 or len(data2_filtered) == 0:\n            return 0.0\n\n        data1_mean = sum(data1_filtered) / len(data1_filtered)\n        data2_mean = sum(data2_filtered) / len(data2_filtered)\n\n        numerator = sum([(data1_filtered[i] - data1_mean) * (data2_filtered[i] - data2_mean) for i in range(len(data1_filtered))])\n        denominator = math.sqrt(sum([(x - data1_mean) ** 2 for x in data1_filtered]) * sum([(y - data2_mean) ** 2 for y in data2_filtered]))\n\n        if denominator == 0:\n            return 0.0\n\n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outlier_indices = [i for i in range(len(data)) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            return [x for i, x in enumerate(data) if i not in outlier_indices]\n\n        data1_filtered = remove_outlier(data1)\n        data2_filtered = remove_outlier(data2)\n\n        n = len(data1_filtered)\n        if n == 0:\n            return 0.0\n        \n        data1_mean = sum(data1_filtered) / n\n        data2_mean = sum(data2_filtered) / n\n        num = sum([(data1_filtered[i] - data1_mean) * (data2_filtered[i] - data2_mean) for i in range(n)])\n        den = math.sqrt(sum([(data1_filtered[i] - data1_mean) ** 2 for i in range(n)]) * sum([(data2_filtered[i] - data2_mean) ** 2 for i in range(n)])\n\n        return num / den if den != 0 else 0.0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outliers = [i for i in range(len(data)) if data[i] > data_mean + 2 * data_std or data[i] < data_mean - 2 * data_std]\n            return [data[i] for i in range(len(data)) if i not in outliers]\n\n        data1_filtered = remove_outlier(data1)\n        data2_filtered = remove_outlier(data2)\n\n        if len(data1_filtered) == 0 or len(data2_filtered) == 0:\n            return 0.0\n\n        data1_mean = sum(data1_filtered) / len(data1_filtered)\n        data2_mean = sum(data2_filtered) / len(data2_filtered)\n\n        numerator = sum([(data1_filtered[i] - data1_mean) * (data2_filtered[i] - data2_mean) for i in range(len(data1_filtered)])\n        denominator = math.sqrt(sum([(data1_filtered[i] - data1_mean) ** 2 for i in range(len(data1_filtered)]) * sum([(data2_filtered[i] - data2_mean) ** 2 for i in range(len(data2_filtered)]))\n\n        if denominator == 0:\n            return 0.0\n\n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outliers(data):\n            data_mean = sum(data) / len(data)\n            data_std = (sum([(x - data_mean) ** 2 for x in data]) / len(data)) ** 0.5\n            outliers = [i for i in range(len(data)) if data[i] > data_mean + 2 * data_std or data[i] < data_mean - 2 * data_std]\n            return [x for i, x in enumerate(data) if i not in outliers]\n\n        data1_filtered = remove_outliers(data1)\n        data2_filtered = remove_outliers(data2)\n\n        if not data1_filtered or not data2_filtered:\n            return 0.0\n\n        data1_mean = sum(data1_filtered) / len(data1_filtered)\n        data2_mean = sum(data2_filtered) / len(data2_filtered)\n\n        numerator = sum((data1_filtered[i] - data1_mean) * (data2_filtered[i] - data2_mean) for i in range(len(data1_filtered)))\n        denominator = (sum((x - data1_mean) ** 2 for x in data1_filtered) * sum((y - data2_mean) ** 2 for y in data2_filtered)) ** 0.5\n\n        if denominator == 0:\n            return 0.0\n\n        correlation_coefficient = numerator / denominator\n        return correlation_coefficient",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        def remove_outlier(data):\n            data_mean = sum(data) / len(data)\n            data_std = math.sqrt(sum([(x - data_mean) ** 2 for x in data]) / len(data))\n            outlier_indices = [i for i in range(len(data)) if data[i] < data_mean - 2 * data_std or data[i] > data_mean + 2 * data_std]\n            return [data[i] for i in range(len(data)) if i not in outlier_indices]\n\n        data1_filtered = remove_outlier(data1)\n        data2_filtered = remove_outlier(data2)\n\n        if len(data1_filtered) == 0 or len(data2_filtered) == 0:\n            return 0.0\n\n        data1_mean = sum(data1_filtered) / len(data1_filtered)\n        data2_mean = sum(data2_filtered) / len(data2_filtered)\n\n        numerator = sum([(data1_filtered[i] - data1_mean) * (data2_filtered[i] - data2_mean) for i in range(len(data1_filtered)])\n        denominator = math.sqrt(sum([(x - data1_mean) ** 2 for x in data1_filtered]) * sum([(x - data2_mean) ** 2 for x in data2_filtered])\n\n        if denominator == 0:\n            return 0.0\n\n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        data1_mean = sum(data1) / len(data1)\n        data1_std = (sum([(x - data1_mean) ** 2 for x in data1]) / len(data1)) ** 0.5\n        data1_outliers = [i for i in range(len(data1)) if data1[i] < data1_mean - 2 * data1_std or data1[i] > data1_mean + 2 * data1_std]\n\n        data2_mean = sum(data2) / len(data2)\n        data2_std = (sum([(x - data2_mean) ** 2 for x in data2]) / len(data2)) ** 0.5\n        data2_outliers = [i for i in range(len(data2)) if data2[i] < data2_mean - 2 * data2_std or data2[i] > data2_mean + 2 * data2_std]\n\n        outliers_indices = set(data1_outliers).union(set(data2_outliers))\n\n        data1_filtered = [data1[i] for i in range(len(data1)) if i not in outliers_indices]\n        data2_filtered = [data2[i] for i in range(len(data2)) if i not in outliers_indices]\n\n        if len(data1_filtered) == 0 or len(data2_filtered) == 0:\n            return 0\n\n        mean1 = sum(data1_filtered) / len(data1_filtered)\n        mean2 = sum(data2_filtered) / len(data2_filtered)\n\n        numerator = sum([(data1_filtered[i] - mean1) * (data2_filtered[i] - mean2) for i in range(len(data1_filtered))])\n        denominator = (sum([(x - mean1) ** 2 for x in data1_filtered]) * sum([(x - mean2) ** 2 for x in data2_filtered])) ** 0.5\n\n        if denominator == 0:\n            return 0\n\n        return numerator / denominator",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        data1_mean = DataStatistics4.mean(data1)\n        data1_std = DataStatistics4.standard_deviation(data1)\n        data2_mean = DataStatistics4.mean(data2)\n        data2_std = DataStatistics4.standard_deviation(data2)\n\n        outliers_data1 = [i for i in range(len(data1)) if data1[i] < data1_mean - 2 * data1_std or data1[i] > data1_mean + 2 * data1_std]\n        outliers_data2 = [i for i in range(len(data2)) if data2[i] < data2_mean - 2 * data2_std or data2[i] > data2_mean + 2 * data2_std]\n\n        outliers_indices = set(outliers_data1 + outliers_data2)\n\n        data1_filtered = [val for idx, val in enumerate(data1) if idx not in outliers_indices]\n        data2_filtered = [val for idx, val in enumerate(data2) if idx not in outliers_indices]\n\n        mean1 = DataStatistics4.mean(data1_filtered)\n        mean2 = DataStatistics4.mean(data2_filtered)\n\n        if len(data1_filtered) > 0 and len(data2_filtered) > 0:\n            numerator = sum((data1_filtered[i] - mean1) * (data2_filtered[i] - mean2) for i in range(len(data1_filtered)))\n            denominator = len(data1_filtered) * DataStatistics4.standard_deviation(data1_filtered) * DataStatistics4.standard_deviation(data2_filtered)\n            return numerator / denominator if denominator != 0 else 0\n        else:\n            return 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        data1_mean = sum(data1) / len(data1)\n        data1_std = (sum([(x - data1_mean) ** 2 for x in data1]) / len(data1)) ** 0.5\n        data2_mean = sum(data2) / len(data2)\n        data2_std = (sum([(x - data2_mean) ** 2 for x in data2]) / len(data2)) ** 0.5\n        \n        data1_outliers = [i for i in range(len(data1)) if abs(data1[i] - data1_mean) > 2 * data1_std]\n        data2_outliers = [i for i in range(len(data2)) if abs(data2[i] - data2_mean) > 2 * data2_std]\n        \n        outliers_indices = set(data1_outliers).union(set(data2_outliers))\n        \n        data1_filtered = [data1[i] for i in range(len(data1)) if i not in outliers_indices]\n        data2_filtered = [data2[i] for i in range(len(data2)) if i not in outliers_indices]\n        \n        mean1 = sum(data1_filtered) / len(data1_filtered)\n        mean2 = sum(data2_filtered) / len(data2_filtered)\n        \n        numerator = sum([(data1_filtered[i] - mean1) * (data2_filtered[i] - mean2) for i in range(len(data1_filtered))])\n        denominator = (sum([(x - mean1) ** 2 for x in data1_filtered]) * sum([(x - mean2) ** 2 for x in data2_filtered])) ** 0.5\n        \n        return numerator / denominator if denominator != 0 else 0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        data1_mean = sum(data1) / len(data1)\n        data1_std = (sum([(x - data1_mean) ** 2 for x in data1]) / len(data1)) ** 0.5\n        data2_mean = sum(data2) / len(data2)\n        data2_std = (sum([(x - data2_mean) ** 2 for x in data2]) / len(data2)) ** 0.5\n\n        data1_outliers = [i for i in range(len(data1)) if data1[i] < data1_mean - 2 * data1_std or data1[i] > data1_mean + 2 * data1_std]\n        data2_outliers = [i for i in range(len(data2)) if data2[i] < data2_mean - 2 * data2_std or data2[i] > data2_mean + 2 * data2_std]\n\n        data_outliers = list(set(data1_outliers).union(set(data2_outliers)))\n\n        data1_cleaned = [data1[i] for i in range(len(data1)) if i not in data_outliers]\n        data2_cleaned = [data2[i] for i in range(len(data2)) if i not in data_outliers]\n\n        mean1 = sum(data1_cleaned) / len(data1_cleaned)\n        mean2 = sum(data2_cleaned) / len(data2_cleaned)\n\n        if len(data1_cleaned) != 0 and len(data2_cleaned) != 0:\n            numerator = sum([(data1_cleaned[i] - mean1) * (data2_cleaned[i] - mean2) for i in range(len(data1_cleaned)])\n            denominator = (sum([(x - mean1) ** 2 for x in data1_cleaned]) * sum([(x - mean2) ** 2 for x in data2_cleaned])) ** 0.5\n\n            if denominator != 0:\n                return numerator / denominator\n            else:\n                return 0.0\n        else:\n            return 0.0",
                false
            ],
            [
                "def robust_correlation_coefficient(data1, data2):\n        data1_mean = sum(data1) / len(data1)\n        data2_mean = sum(data2) / len(data2)\n        data1_std = math.sqrt(sum([(x - data1_mean) ** 2 for x in data1]) / len(data1))\n        data2_std = math.sqrt(sum([(x - data2_mean) ** 2 for x in data2]) / len(data2)\n\n        data1_outliers = [i for i in range(len(data1)) if abs(data1[i] - data1_mean) > 2 * data1_std]\n        data2_outliers = [i for i in range(len(data2)) if abs(data2[i] - data2_mean) > 2 * data2_std]\n\n        outliers_indices = set(data1_outliers).union(set(data2_outliers))\n\n        data1_filtered = [data1[i] for i in range(len(data1)) if i not in outliers_indices]\n        data2_filtered = [data2[i] for i in range(len(data2)) if i not in outliers_indices]\n\n        mean1 = sum(data1_filtered) / len(data1_filtered)\n        mean2 = sum(data2_filtered) / len(data2_filtered)\n\n        if data1_std * data2_std == 0:\n            return 0\n        else:\n            numerator = sum([(data1_filtered[i] - mean1) * (data2_filtered[i] - mean2) for i in range(len(data1_filtered))])\n            denominator = len(data1_filtered) * data1_std * data2_std\n            return numerator / denominator",
                false
            ]
        ]
    },
    "4": {
        "level 1": [
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for i in range(len(x_interp)):\n            if x_interp[i] < min(x) or x_interp[i] > max(x):\n                y_interp.append(None)  # Out of bounds\n            else:\n                for j in range(len(x) - 1):\n                    if x[j] <= x_interp[i] <= x[j + 1]:\n                        y_val = y[j] + (y[j + 1] - y[j]) * (x_interp[i] - x[j]) / (x[j + 1] - x[j])\n                        y_interp.append(y_val)\n                        break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    interpolated_y = []\n    for idx, interp_point in enumerate(x_interp):\n        for i in range(len(x) - 1):\n            if x[i] <= interp_point <= x[i + 1]:\n                interpolated_value = y[i] + ((y[i + 1] - y[i]) / (x[i + 1] - x[i])) * (interp_point - x[i])\n                interpolated_y.append(interpolated_value)\n                break\n    return interpolated_y",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    interpolated_values = []\n    for i in range(len(x_interp)):\n        for j in range(len(x) - 1):\n            if x[j] <= x_interp[i] <= x[j + 1]:\n                slope = (y[j + 1] - y[j]) / (x[j + 1] - x[j])\n                interpolated_value = y[j] + slope * (x_interp[i] - x[j])\n                interpolated_values.append(interpolated_value)\n                break\n    return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for i in range(len(x_interp)):\n            for j in range(len(x) - 1):\n                if x[j] <= x_interp[i] <= x[j + 1]:\n                    y_val = y[j] + (y[j + 1] - y[j]) * (x_interp[i] - x[j]) / (x[j + 1] - x[j])\n                    y_interp.append(y_val)\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        interpolated_values = []\n        for interp_point in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= interp_point <= x[i + 1]:\n                    slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i])\n                    interpolated_value = y[i] + slope * (interp_point - x[i])\n                    interpolated_values.append(interpolated_value)\n                    break\n        return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    interpolated_values = []\n    for val in x_interp:\n        if val < min(x):\n            interpolated_values.append(y[0])\n        elif val > max(x):\n            interpolated_values.append(y[-1])\n        else:\n            for i in range(len(x) - 1):\n                if x[i] <= val < x[i+1]:\n                    interpolated_y = y[i] + ((val - x[i]) / (x[i+1] - x[i])) * (y[i+1] - y[i])\n                    interpolated_values.append(interpolated_y)\n                    break\n    return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        interpolated_values = []\n        for val in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= val <= x[i + 1]:\n                    interpolated_y = y[i] + (y[i + 1] - y[i]) * (val - x[i]) / (x[i + 1] - x[i])\n                    interpolated_values.append(interpolated_y)\n                    break\n        return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        interpolated_values = []\n        for point in x_interp:\n            if point < min(x) or point > max(x):\n                raise ValueError(\"Interpolation point is outside the range of provided data.\")\n            for i in range(len(x) - 1):\n                if x[i] <= point <= x[i + 1]:\n                    interpolated_value = y[i] + (y[i + 1] - y[i]) * (point - x[i]) / (x[i + 1] - x[i])\n                    interpolated_values.append(interpolated_value)\n                    break\n        return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        interpolated_y_values = []\n        for i in range(len(x_interp)):\n            for j in range(len(x) - 1):\n                if x[j] <= x_interp[i] <= x[j + 1]:\n                    slope = (y[j + 1] - y[j]) / (x[j + 1] - x[j])\n                    interpolated_y = y[j] + slope * (x_interp[i] - x[j])\n                    interpolated_y_values.append(interpolated_y)\n                    break\n        return interpolated_y_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        interpolated_values = []\n        for interp_point in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= interp_point <= x[i + 1]:\n                    y_val = y[i] + ((interp_point - x[i]) / (x[i + 1] - x[i])) * (y[i + 1] - y[i])\n                    interpolated_values.append(y_val)\n                    break\n        return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        interpolated_values = []\n        for i in range(len(x_interp)):\n            for j in range(len(x) - 1):\n                if x[j] <= x_interp[i] <= x[j + 1]:\n                    interpolated_value = ((x_interp[i] - x[j]) / (x[j + 1] - x[j])) * (y[j + 1] - y[j]) + y[j]\n                    interpolated_values.append(interpolated_value)\n                    break\n        return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for val in x_interp:\n            if val < min(x):\n                y_interp.append(y[0] + (val - x[0]) * (y[1] - y[0]) / (x[1] - x[0]))\n            elif val > max(x):\n                y_interp.append(y[-1] + (val - x[-1]) * (y[-1] - y[-2]) / (x[-1] - x[-2]))\n            else:\n                for i in range(len(x) - 1):\n                    if x[i] <= val <= x[i + 1]:\n                        y_interp.append(y[i] + (val - x[i]) * (y[i + 1] - y[i]) / (x[i + 1] - x[i]))\n                        break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for x_new in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= x_new <= x[i + 1]:\n                    y_val = y[i] + (y[i + 1] - y[i]) * (x_new - x[i]) / (x[i + 1] - x[i])\n                    y_interp.append(y_val)\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x)-1):\n                if xi >= x[i] and xi <= x[i+1]:\n                    y_val = y[i] + (xi - x[i]) * (y[i+1] - y[i]) / (x[i+1] - x[i])\n                    y_interp.append(y_val)\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        interpolated_values = []\n        for i in range(len(x_interp)):\n            for j in range(len(x) - 1):\n                if x[j] <= x_interp[i] <= x[j + 1]:\n                    interpolated_value = y[j] + ((y[j + 1] - y[j]) / (x[j + 1] - x[j])) * (x_interp[i] - x[j])\n                    interpolated_values.append(interpolated_value)\n                    break\n        return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for point in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= point <= x[i + 1]:\n                    slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i])\n                    interpolated_value = y[i] + slope * (point - x[i])\n                    y_interp.append(interpolated_value)\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    interpolated_values = []\n    for i in range(len(x_interp)):\n        for j in range(len(x) - 1):\n            if x[j] <= x_interp[i] <= x[j + 1]:\n                slope = (y[j + 1] - y[j]) / (x[j + 1] - x[j])\n                interpolated_value = y[j] + slope * (x_interp[i] - x[j])\n                interpolated_values.append(interpolated_value)\n                break\n    return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    interpolated_points = []\n    for i in range(len(x_interp)):\n        for j in range(len(x) - 1):\n            if x[j] <= x_interp[i] <= x[j + 1]:\n                slope = (y[j + 1] - y[j]) / (x[j + 1] - x[j])\n                interpolated_y = y[j] + slope * (x_interp[i] - x[j])\n                interpolated_points.append(interpolated_y)\n                break\n    return interpolated_points",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    interpolated_y = []\n    for i in range(len(x_interp)):\n        for j in range(len(x) - 1):\n            if x[j] <= x_interp[i] <= x[j + 1]:\n                slope = (y[j + 1] - y[j]) / (x[j + 1] - x[j])\n                interpolated_y.append(y[j] + slope * (x_interp[i] - x[j]))\n                break\n    return interpolated_y",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for i in range(len(x_interp)):\n            for j in range(len(x) - 1):\n                if x[j] <= x_interp[i] <= x[j + 1]:\n                    y_val = y[j] + (y[j + 1] - y[j]) * (x_interp[i] - x[j]) / (x[j + 1] - x[j])\n                    y_interp.append(y_val)\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        interpolated_values = []\n        for val in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= val <= x[i + 1]:\n                    slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i])\n                    interpolated_value = y[i] + slope * (val - x[i])\n                    interpolated_values.append(interpolated_value)\n                    break\n        return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        interpolated_values = []\n        for i in range(len(x_interp)):\n            for j in range(len(x) - 1):\n                if x[j] <= x_interp[i] <= x[j + 1]:\n                    slope = (y[j + 1] - y[j]) / (x[j + 1] - x[j])\n                    interpolated_y = y[j] + slope * (x_interp[i] - x[j])\n                    interpolated_values.append(interpolated_y)\n        return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    interpolated_values = []\n    for val in x_interp:\n        for i in range(len(x) - 1):\n            if x[i] <= val <= x[i + 1]:\n                interpolated_y = y[i] + ((y[i + 1] - y[i]) / (x[i + 1] - x[i])) * (val - x[i])\n                interpolated_values.append(interpolated_y)\n                break\n    return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for val in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= val <= x[i + 1]:\n                    slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i])\n                    y_val = y[i] + slope * (val - x[i])\n                    y_interp.append(y_val)\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        interpolated_values = []\n        for interp_point in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= interp_point <= x[i + 1]:\n                    interpolated_value = y[i] + ((y[i + 1] - y[i]) / (x[i + 1] - x[i])) * (interp_point - x[i])\n                    interpolated_values.append(interpolated_value)\n                    break\n        return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for i in range(len(x_interp)):\n        for j in range(len(x) - 1):\n            if x[j] <= x_interp[i] <= x[j + 1]:\n                y_val = y[j] + ((y[j + 1] - y[j]) / (x[j + 1] - x[j])) * (x_interp[i] - x[j])\n                y_interp.append(y_val)\n                break\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi < x[i + 1]:\n                    slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i])\n                    y_val = y[i] + slope * (xi - x[i])\n                    y_interp.append(y_val)\n                    break\n                elif xi == x[i + 1]:\n                    y_interp.append(y[i + 1])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for i in range(len(x_interp)):\n            for j in range(len(x) - 1):\n                if x[j] <= x_interp[i] <= x[j+1]:\n                    slope = (y[j+1] - y[j]) / (x[j+1] - x[j])\n                    y_val = y[j] + slope * (x_interp[i] - x[j])\n                    y_interp.append(y_val)\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        interpolated_values = []\n        for i in range(len(x_interp)):\n            for j in range(len(x) - 1):\n                if x[j] <= x_interp[i] <= x[j + 1]:\n                    slope = (y[j + 1] - y[j]) / (x[j + 1] - x[j])\n                    interpolated_value = y[j] + slope * (x_interp[i] - x[j])\n                    interpolated_values.append(interpolated_value)\n                    break\n        return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for val in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= val <= x[i + 1]:\n                    y_val = y[i] + (y[i + 1] - y[i]) * (val - x[i]) / (x[i + 1] - x[i])\n                    y_interp.append(y_val)\n                    break\n        return y_interp",
                false
            ]
        ],
        "level 2": [
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for x_point in x_interp:\n        idx = min(range(len(x)), key=lambda i: abs(x[i] - x_point))\n        y_interp.append(y[idx])\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for i in range(len(x_interp)):\n            closest_x = min(x, key=lambda val: abs(val - x_interp[i]))\n            idx = x.index(closest_x)\n            y_interp.append(y[idx])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    interpolated_y = []\n    for interp_point in x_interp:\n        idx = min(range(len(x)), key=lambda i: abs(x[i] - interp_point))\n        interpolated_y.append(y[idx])\n    return interpolated_y",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    interpolated_values = []\n    for point in x_interp:\n        nearest_index = min(range(len(x)), key=lambda i: abs(x[i] - point))\n        interpolated_values.append(y[nearest_index])\n    return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for x_i in x_interp:\n            idx = min(range(len(x)), key=lambda i: abs(x[i] - x_i))\n            y_interp.append(y[idx])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for interp_point in x_interp:\n        nearest_x = min(x, key=lambda x_val: abs(x_val - interp_point))\n        nearest_index = x.index(nearest_x)\n        y_interp.append(y[nearest_index])\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for x_i in x_interp:\n        closest_x = min(x, key=lambda xi: abs(xi - x_i))\n        closest_index = x.index(closest_x)\n        y_interp.append(y[closest_index])\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    interpolated_values = []\n    for point in x_interp:\n        closest_x = min(x, key=lambda val: abs(val - point))\n        index = x.index(closest_x)\n        interpolated_values.append(y[index])\n    return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for x_val in x_interp:\n        closest_x = min(x, key=lambda val: abs(val - x_val))\n        idx = x.index(closest_x)\n        y_interp.append(y[idx])\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for point in x_interp:\n        closest_x = min(x, key=lambda x_val: abs(x_val - point))\n        closest_index = x.index(closest_x)\n        y_interp.append(y[closest_index])\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    interpolated_values = []\n    for interp_point in x_interp:\n        closest_x = min(x, key=lambda x_val: abs(x_val - interp_point))\n        interpolated_values.append(y[x.index(closest_x)])\n    return interpolated_values",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for x_point in x_interp:\n            closest_x = min(x, key=lambda val: abs(val - x_point))\n            closest_index = x.index(closest_x)\n            y_interp.append(y[closest_index])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for point in x_interp:\n            idx = 0\n            while idx < len(x) - 1 and x[idx + 1] < point:\n                idx += 1\n            y_interp.append(y[idx])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for interp_point in x_interp:\n            closest_x_idx = min(range(len(x)), key=lambda i: abs(x[i] - interp_point))\n            y_interp.append(y[closest_x_idx])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            idx = len([xp for xp in x if xp <= xi]) - 1\n            y_interp.append(y[idx])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for x_point in x_interp:\n        closest_x = min(x, key=lambda x_val: abs(x_val - x_point))\n        closest_index = x.index(closest_x)\n        y_interp.append(y[closest_index])\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            index = 0\n            for i in range(len(x)):\n                if x[i] <= xi:\n                    index = i\n            y_interp.append(y[index])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            closest_x = min(x, key=lambda x_val: abs(x_val - xi))\n            y_interp.append(y[x.index(closest_x)])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            closest_x = min(x, key=lambda x_val: abs(x_val - xi))\n            closest_index = x.index(closest_x)\n            y_interp.append(y[closest_index])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for interp_point in x_interp:\n        idx = 0\n        for i in range(1, len(x)):\n            if x[i] <= interp_point:\n                idx = i\n        y_interp.append(y[idx])\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            nearest_x = min(x, key=lambda val: abs(val - xi))\n            nearest_index = x.index(nearest_x)\n            y_interp.append(y[nearest_index])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    index = 0\n    for point in x_interp:\n        while index < len(x) and point >= x[index]:\n            index += 1\n        y_interp.append(y[index - 1])\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            idx = np.abs(np.array(x) - xi).argmin()\n            y_interp.append(y[idx])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for x_point in x_interp:\n            if x_point in x:\n                idx = x.index(x_point)\n                y_interp.append(y[idx])\n            else:\n                idx = 0\n                while x[idx] < x_point:\n                    idx += 1\n                y_interp.append(y[idx-1])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for point in x_interp:\n            closest_x = min(x, key=lambda xi: abs(xi - point))\n            closest_index = x.index(closest_x)\n            y_interp.append(y[closest_index])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for x_point in x_interp:\n            closest_x_index = min(range(len(x)), key=lambda i: abs(x[i] - x_point))\n            y_interp.append(y[closest_x_index])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for interp_point in x_interp:\n        idx = np.abs(np.array(x) - interp_point).argmin()\n        y_interp.append(y[idx])\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for xi in x_interp:\n        idx = min(range(len(x)), key=lambda i: abs(x[i] - xi))\n        y_interp.append(y[idx])\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            index = 0\n            for i in range(len(x)):\n                if xi < x[i]:\n                    index = i\n                    break\n                else:\n                    index = i\n            y_interp.append(y[index])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for point in x_interp:\n            idx = np.argmin(np.abs(np.array(x) - point))\n            y_interp.append(y[idx])\n        return y_interp",
                false
            ]
        ],
        "level 3": [
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if xi <= x[i+1]:\n                    if xi - x[i] < x[i+1] - xi:\n                        y_interp.append(y[i])\n                    else:\n                        y_interp.append(y[i+1])\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    if x[i + 1] - xi < xi - x[i]:\n                        yi = y[i + 1]\n                    else:\n                        yi = y[i]\n                    y_interp.append(yi)\n                    break\n        return y_interp",
                true
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if xi >= x[i] and xi < x[i + 1]:\n                    if x[i + 1] - xi < xi - x[i]:\n                        yi = y[i + 1]\n                    else:\n                        yi = y[i]\n                    y_interp.append(yi)\n                    break\n        return y_interp",
                true
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if xi >= x[i] and xi < x[i + 1]:\n                    if x[i + 1] - xi < xi - x[i]:\n                        yi = y[i + 1]\n                    else:\n                        yi = y[i]\n                    y_interp.append(yi)\n                    break\n        return y_interp",
                true
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i + 1] >= xi >= x[i]:\n                    if x[i + 1] - xi < xi - x[i]:\n                        yi = y[i + 1]\n                    else:\n                        yi = y[i]\n                    y_interp.append(yi)\n                    break\n        return y_interp",
                true
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi < x[i + 1]:\n                    if xi - x[i] < x[i + 1] - xi:\n                        yi = y[i]\n                    else:\n                        yi = y[i + 1]\n                    y_interp.append(yi)\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for xi in x_interp:\n        for i in range(len(x)-1):\n            if x[i] <= xi < x[i+1]:\n                if xi - x[i] < x[i+1] - xi:\n                    yi = y[i]\n                else:\n                    yi = y[i+1]\n                y_interp.append(yi)\n                break\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi < x[i + 1]:\n                    yi = y[i]\n                    y_interp.append(yi)\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        i = 0\n        for xi in x_interp:\n            while i < len(x) - 1 and xi > x[i + 1]:\n                i += 1\n            y_interp.append(y[i])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        i = 0\n        for xi in x_interp:\n            while i < len(x) - 1 and xi > x[i + 1]:\n                i += 1\n            y_interp.append(y[i])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi < x[i + 1]:\n                    if xi - x[i] < x[i + 1] - xi:\n                        y_interp.append(y[i])\n                    else:\n                        y_interp.append(y[i + 1])\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for xi in x_interp:\n        for i in range(len(x) - 1):\n            if x[i] <= xi < x[i + 1]:\n                y_interp.append(y[i+1] if xi - x[i] < x[i+1] - xi else y[i])\n                break\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for xi in x_interp:\n        for i in range(len(x) - 1):\n            if x[i] <= xi <= x[i+1]:\n                if abs(xi - x[i]) <= abs(xi - x[i+1]):\n                    y_interp.append(y[i])\n                else:\n                    y_interp.append(y[i+1])\n                break\n    return y_interp",
                true
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi < x[i + 1]:\n                    y_interp.append(y[i] if xi - x[i] <= x[i + 1] - xi else y[i + 1])\n        return y_interp",
                true
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi < x[i+1]:\n                    y_interp.append(y[i])\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi < x[i + 1]:\n                    if abs(xi - x[i]) <= abs(xi - x[i + 1]):\n                        y_interp.append(y[i])\n                    else:\n                        y_interp.append(y[i + 1])\n                    break\n                elif xi == x[-1]:\n                    y_interp.append(y[-1])\n        return y_interp",
                true
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        i = 0\n        for xi in x_interp:\n            while i < len(x) - 1 and xi > x[i + 1]:\n                i += 1\n            y_interp.append(y[i] if xi - x[i] <= x[i + 1] - xi else y[i + 1])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x)-1):\n                if x[i] <= xi < x[i+1]:\n                    if abs(xi - x[i]) < abs(xi - x[i+1]):\n                        y_interp.append(y[i])\n                    else:\n                        y_interp.append(y[i+1])\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x)-1):\n                if xi >= x[i] and xi < x[i+1]:\n                    if xi - x[i] <= x[i+1] - xi:\n                        y_interp.append(y[i])\n                    else:\n                        y_interp.append(y[i+1])\n                    break\n        return y_interp",
                true
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            i = 0\n            while i < len(x) - 1 and xi > x[i + 1]:\n                i += 1\n            y_interp.append(y[i + 1] if xi - x[i] < x[i + 1] - xi else y[i])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        i = 0\n        for xi in x_interp:\n            while i < len(x) - 1 and xi > x[i + 1]:\n                i += 1\n            y_interp.append(y[i])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n    y_interp = []\n    for xi in x_interp:\n        for i in range(len(x) - 1):\n            if x[i] <= xi < x[i + 1]:\n                y_interp.append(y[i])\n                break\n            elif xi >= x[-1]:\n                y_interp.append(y[-1])\n                break\n    return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x)-1):\n                if x[i] <= xi < x[i+1]:\n                    if xi - x[i] < x[i+1] - xi:\n                        y_interp.append(y[i])\n                    else:\n                        y_interp.append(y[i+1])\n                    break\n                elif xi == x[i]:\n                    y_interp.append(y[i])\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi < x[i + 1]:\n                    y_interp.append(y[i])\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x)-1):\n                if x[i] <= xi < x[i+1]:\n                    y_interp.append(y[i])\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        i = 0\n        for xi in x_interp:\n            while i < len(x) - 1 and x[i + 1] < xi:\n                i += 1\n            y_interp.append(y[i])\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi < x[i + 1]:\n                    y_interp.append(y[i + 1] if xi >= (x[i] + x[i + 1]) / 2 else y[i])\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi < x[i + 1]:\n                    yi = y[i + 1] if xi >= (x[i] + x[i + 1]) / 2 else y[i]\n                    y_interp.append(yi)\n                    break\n        return y_interp",
                false
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    y_interp.append(y[i + 1] if xi > (x[i] + x[i + 1]) / 2 else y[i])\n                    break\n        return y_interp",
                true
            ],
            [
                "def interpolate_1d_piecewise(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if xi >= x[i] and xi < x[i + 1]:\n                    yi = y[i] if xi - x[i] < x[i + 1] - xi else y[i + 1]\n                    y_interp.append(yi)\n                    break\n            else:\n                y_interp.append(y[-1])\n        return y_interp",
                false
            ]
        ]
    }
}